/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 105);
/******/ })
/************************************************************************/
/******/ ({

/***/ 105:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(106);


/***/ }),

/***/ 106:
/***/ (function(module, exports) {

eval("// SmoothScroll for websites v1.2.1\n// Licensed under the terms of the MIT license.\n\n// People involved\n//  - Balazs Galambosi (maintainer)  \n//  - Michael Herf     (Pulse Algorithm)\n\n(function () {\n\n    // Scroll Variables (tweakable)\n    var defaultOptions = {\n\n        // Scrolling Core\n        frameRate: 150, // [Hz]\n        animationTime: 400, // [px]\n        stepSize: 120, // [px]\n\n        // Pulse (less tweakable)\n        // ratio of \"tail\" to \"acceleration\"\n        pulseAlgorithm: true,\n        pulseScale: 8,\n        pulseNormalize: 1,\n\n        // Acceleration\n        accelerationDelta: 20, // 20\n        accelerationMax: 1, // 1\n\n        // Keyboard Settings\n        keyboardSupport: true, // option\n        arrowScroll: 50, // [px]\n\n        // Other\n        touchpadSupport: true,\n        fixedBackground: true,\n        excluded: \"\"\n    };\n\n    var options = defaultOptions;\n\n    // Other Variables\n    var isExcluded = false;\n    var isFrame = false;\n    var direction = { x: 0, y: 0 };\n    var initDone = false;\n    var root = document.documentElement;\n    var activeElement;\n    var observer;\n    var deltaBuffer = [120, 120, 120];\n\n    var key = { left: 37, up: 38, right: 39, down: 40, spacebar: 32,\n        pageup: 33, pagedown: 34, end: 35, home: 36 };\n\n    /***********************************************\n     * SETTINGS\n     ***********************************************/\n\n    var options = defaultOptions;\n\n    /***********************************************\n     * INITIALIZE\n     ***********************************************/\n\n    /**\n     * Tests if smooth scrolling is allowed. Shuts down everything if not.\n     */\n    function initTest() {\n\n        var disableKeyboard = false;\n\n        // disable keyboard support if anything above requested it\n        if (disableKeyboard) {\n            removeEvent(\"keydown\", keydown);\n        }\n\n        if (options.keyboardSupport && !disableKeyboard) {\n            addEvent(\"keydown\", keydown);\n        }\n    }\n\n    /**\n     * Sets up scrolls array, determines if frames are involved.\n     */\n    function init() {\n\n        if (!document.body) return;\n\n        var body = document.body;\n        var html = document.documentElement;\n        var windowHeight = window.innerHeight;\n        var scrollHeight = body.scrollHeight;\n\n        // check compat mode for root element\n        root = document.compatMode.indexOf('CSS') >= 0 ? html : body;\n        activeElement = body;\n\n        initTest();\n        initDone = true;\n\n        // Checks if this script is running in a frame\n        if (top != self) {\n            isFrame = true;\n        }\n\n        /**\n         * This fixes a bug where the areas left and right to \n         * the content does not trigger the onmousewheel event\n         * on some pages. e.g.: html, body { height: 100% }\n         */\n        else if (scrollHeight > windowHeight && (body.offsetHeight <= windowHeight || html.offsetHeight <= windowHeight)) {\n\n                html.style.height = 'auto';\n                setTimeout(refresh, 10);\n\n                // clearfix\n                if (root.offsetHeight <= windowHeight) {\n                    var underlay = document.createElement(\"div\");\n                    underlay.style.clear = \"both\";\n                    body.appendChild(underlay);\n                }\n            }\n\n        // disable fixed background\n        if (!options.fixedBackground && !isExcluded) {\n            body.style.backgroundAttachment = \"scroll\";\n            html.style.backgroundAttachment = \"scroll\";\n        }\n    }\n\n    /************************************************\n     * SCROLLING \n     ************************************************/\n\n    var que = [];\n    var pending = false;\n    var lastScroll = +new Date();\n\n    /**\n     * Pushes scroll actions to the scrolling queue.\n     */\n    function scrollArray(elem, left, top, delay) {\n\n        delay || (delay = 1000);\n        directionCheck(left, top);\n\n        if (options.accelerationMax != 1) {\n            var now = +new Date();\n            var elapsed = now - lastScroll;\n            if (elapsed < options.accelerationDelta) {\n                var factor = (1 + 30 / elapsed) / 2;\n                if (factor > 1) {\n                    factor = Math.min(factor, options.accelerationMax);\n                    left *= factor;\n                    top *= factor;\n                }\n            }\n            lastScroll = +new Date();\n        }\n\n        // push a scroll command\n        que.push({\n            x: left,\n            y: top,\n            lastX: left < 0 ? 0.99 : -0.99,\n            lastY: top < 0 ? 0.99 : -0.99,\n            start: +new Date()\n        });\n\n        // don't act if there's a pending queue\n        if (pending) {\n            return;\n        }\n\n        var scrollWindow = elem === document.body;\n\n        var step = function step(time) {\n\n            var now = +new Date();\n            var scrollX = 0;\n            var scrollY = 0;\n\n            for (var i = 0; i < que.length; i++) {\n\n                var item = que[i];\n                var elapsed = now - item.start;\n                var finished = elapsed >= options.animationTime;\n\n                // scroll position: [0, 1]\n                var position = finished ? 1 : elapsed / options.animationTime;\n\n                // easing [optional]\n                if (options.pulseAlgorithm) {\n                    position = pulse(position);\n                }\n\n                // only need the difference\n                var x = item.x * position - item.lastX >> 0;\n                var y = item.y * position - item.lastY >> 0;\n\n                // add this to the total scrolling\n                scrollX += x;\n                scrollY += y;\n\n                // update last values\n                item.lastX += x;\n                item.lastY += y;\n\n                // delete and step back if it's over\n                if (finished) {\n                    que.splice(i, 1);i--;\n                }\n            }\n\n            // scroll left and top\n            if (scrollWindow) {\n                window.scrollBy(scrollX, scrollY);\n            } else {\n                if (scrollX) elem.scrollLeft += scrollX;\n                if (scrollY) elem.scrollTop += scrollY;\n            }\n\n            // clean up if there's nothing left to do\n            if (!left && !top) {\n                que = [];\n            }\n\n            if (que.length) {\n                requestFrame(step, elem, delay / options.frameRate + 1);\n            } else {\n                pending = false;\n            }\n        };\n\n        // start a new queue of actions\n        requestFrame(step, elem, 0);\n        pending = true;\n    }\n\n    /***********************************************\n     * EVENTS\n     ***********************************************/\n\n    /**\n     * Mouse wheel handler.\n     * @param {Object} event\n     */\n    function wheel(event) {\n\n        if (!initDone) {\n            init();\n        }\n\n        var target = event.target;\n        var overflowing = overflowingAncestor(target);\n\n        // use default if there's no overflowing\n        // element or default action is prevented    \n        if (!overflowing || event.defaultPrevented || isNodeName(activeElement, \"embed\") || isNodeName(target, \"embed\") && /\\.pdf/i.test(target.src)) {\n            return true;\n        }\n\n        var deltaX = event.wheelDeltaX || 0;\n        var deltaY = event.wheelDeltaY || 0;\n\n        // use wheelDelta if deltaX/Y is not available\n        if (!deltaX && !deltaY) {\n            deltaY = event.wheelDelta || 0;\n        }\n\n        // check if it's a touchpad scroll that should be ignored\n        if (!options.touchpadSupport && isTouchpad(deltaY)) {\n            return true;\n        }\n\n        // scale by step size\n        // delta is 120 most of the time\n        // synaptics seems to send 1 sometimes\n        if (Math.abs(deltaX) > 1.2) {\n            deltaX *= options.stepSize / 120;\n        }\n        if (Math.abs(deltaY) > 1.2) {\n            deltaY *= options.stepSize / 120;\n        }\n\n        scrollArray(overflowing, -deltaX, -deltaY);\n        event.preventDefault();\n    }\n\n    /**\n     * Keydown event handler.\n     * @param {Object} event\n     */\n    function keydown(event) {\n\n        var target = event.target;\n        var modifier = event.ctrlKey || event.altKey || event.metaKey || event.shiftKey && event.keyCode !== key.spacebar;\n\n        // do nothing if user is editing text\n        // or using a modifier key (except shift)\n        // or in a dropdown\n        if (/input|textarea|select|embed/i.test(target.nodeName) || target.isContentEditable || event.defaultPrevented || modifier) {\n            return true;\n        }\n        // spacebar should trigger button press\n        if (isNodeName(target, \"button\") && event.keyCode === key.spacebar) {\n            return true;\n        }\n\n        var shift,\n            x = 0,\n            y = 0;\n        var elem = overflowingAncestor(activeElement);\n        var clientHeight = elem.clientHeight;\n\n        if (elem == document.body) {\n            clientHeight = window.innerHeight;\n        }\n\n        switch (event.keyCode) {\n            case key.up:\n                y = -options.arrowScroll;\n                break;\n            case key.down:\n                y = options.arrowScroll;\n                break;\n            case key.spacebar:\n                // (+ shift)\n                shift = event.shiftKey ? 1 : -1;\n                y = -shift * clientHeight * 0.9;\n                break;\n            case key.pageup:\n                y = -clientHeight * 0.9;\n                break;\n            case key.pagedown:\n                y = clientHeight * 0.9;\n                break;\n            case key.home:\n                y = -elem.scrollTop;\n                break;\n            case key.end:\n                var damt = elem.scrollHeight - elem.scrollTop - clientHeight;\n                y = damt > 0 ? damt + 10 : 0;\n                break;\n            case key.left:\n                x = -options.arrowScroll;\n                break;\n            case key.right:\n                x = options.arrowScroll;\n                break;\n            default:\n                return true; // a key we don't care about\n        }\n\n        scrollArray(elem, x, y);\n        event.preventDefault();\n    }\n\n    /**\n     * Mousedown event only for updating activeElement\n     */\n    function mousedown(event) {\n        activeElement = event.target;\n    }\n\n    /***********************************************\n     * OVERFLOW\n     ***********************************************/\n\n    var cache = {}; // cleared out every once in while\n    setInterval(function () {\n        cache = {};\n    }, 10 * 1000);\n\n    var uniqueID = function () {\n        var i = 0;\n        return function (el) {\n            return el.uniqueID || (el.uniqueID = i++);\n        };\n    }();\n\n    function setCache(elems, overflowing) {\n        for (var i = elems.length; i--;) {\n            cache[uniqueID(elems[i])] = overflowing;\n        }return overflowing;\n    }\n\n    function overflowingAncestor(el) {\n        var elems = [];\n        var rootScrollHeight = root.scrollHeight;\n        do {\n            var cached = cache[uniqueID(el)];\n            if (cached) {\n                return setCache(elems, cached);\n            }\n            elems.push(el);\n            if (rootScrollHeight === el.scrollHeight) {\n                if (!isFrame || root.clientHeight + 10 < rootScrollHeight) {\n                    return setCache(elems, document.body); // scrolling root in WebKit\n                }\n            } else if (el.clientHeight + 10 < el.scrollHeight) {\n                overflow = getComputedStyle(el, \"\").getPropertyValue(\"overflow-y\");\n                if (overflow === \"scroll\" || overflow === \"auto\") {\n                    return setCache(elems, el);\n                }\n            }\n        } while (el = el.parentNode);\n    }\n\n    /***********************************************\n     * HELPERS\n     ***********************************************/\n\n    function addEvent(type, fn, bubble) {\n        window.addEventListener(type, fn, bubble || false);\n    }\n\n    function removeEvent(type, fn, bubble) {\n        window.removeEventListener(type, fn, bubble || false);\n    }\n\n    function isNodeName(el, tag) {\n        return (el.nodeName || \"\").toLowerCase() === tag.toLowerCase();\n    }\n\n    function directionCheck(x, y) {\n        x = x > 0 ? 1 : -1;\n        y = y > 0 ? 1 : -1;\n        if (direction.x !== x || direction.y !== y) {\n            direction.x = x;\n            direction.y = y;\n            que = [];\n            lastScroll = 0;\n        }\n    }\n\n    var deltaBufferTimer;\n\n    function isTouchpad(deltaY) {\n        if (!deltaY) return;\n        deltaY = Math.abs(deltaY);\n        deltaBuffer.push(deltaY);\n        deltaBuffer.shift();\n        clearTimeout(deltaBufferTimer);\n\n        var allEquals = deltaBuffer[0] == deltaBuffer[1] && deltaBuffer[1] == deltaBuffer[2];\n        var allDivisable = isDivisible(deltaBuffer[0], 120) && isDivisible(deltaBuffer[1], 120) && isDivisible(deltaBuffer[2], 120);\n        return !(allEquals || allDivisable);\n    }\n\n    function isDivisible(n, divisor) {\n        return Math.floor(n / divisor) == n / divisor;\n    }\n\n    var requestFrame = function () {\n        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || function (callback, element, delay) {\n            window.setTimeout(callback, delay || 1000 / 60);\n        };\n    }();\n\n    /***********************************************\n     * PULSE\n     ***********************************************/\n\n    /**\n     * Viscous fluid with a pulse for part and decay for the rest.\n     * - Applies a fixed force over an interval (a damped acceleration), and\n     * - Lets the exponential bleed away the velocity over a longer interval\n     * - Michael Herf, http://stereopsis.com/stopping/\n     */\n    function pulse_(x) {\n        var val, start, expx;\n        // test\n        x = x * options.pulseScale;\n        if (x < 1) {\n            // acceleartion\n            val = x - (1 - Math.exp(-x));\n        } else {\n            // tail\n            // the previous animation ended here:\n            start = Math.exp(-1);\n            // simple viscous drag\n            x -= 1;\n            expx = 1 - Math.exp(-x);\n            val = start + expx * (1 - start);\n        }\n        return val * options.pulseNormalize;\n    }\n\n    function pulse(x) {\n        if (x >= 1) return 1;\n        if (x <= 0) return 0;\n\n        if (options.pulseNormalize == 1) {\n            options.pulseNormalize /= pulse_(1);\n        }\n        return pulse_(x);\n    }\n\n    var isChrome = /chrome/i.test(window.navigator.userAgent);\n    var isMouseWheelSupported = 'onmousewheel' in document;\n\n    if (isMouseWheelSupported && isChrome) {\n        addEvent(\"mousedown\", mousedown);\n        addEvent(\"mousewheel\", wheel);\n        addEvent(\"load\", init);\n    };\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL3d3dy9qcy9TbW9vdGhTY3JvbGwuanM/MWI5NiJdLCJuYW1lcyI6WyJkZWZhdWx0T3B0aW9ucyIsImZyYW1lUmF0ZSIsImFuaW1hdGlvblRpbWUiLCJzdGVwU2l6ZSIsInB1bHNlQWxnb3JpdGhtIiwicHVsc2VTY2FsZSIsInB1bHNlTm9ybWFsaXplIiwiYWNjZWxlcmF0aW9uRGVsdGEiLCJhY2NlbGVyYXRpb25NYXgiLCJrZXlib2FyZFN1cHBvcnQiLCJhcnJvd1Njcm9sbCIsInRvdWNocGFkU3VwcG9ydCIsImZpeGVkQmFja2dyb3VuZCIsImV4Y2x1ZGVkIiwib3B0aW9ucyIsImlzRXhjbHVkZWQiLCJpc0ZyYW1lIiwiZGlyZWN0aW9uIiwieCIsInkiLCJpbml0RG9uZSIsInJvb3QiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImFjdGl2ZUVsZW1lbnQiLCJvYnNlcnZlciIsImRlbHRhQnVmZmVyIiwia2V5IiwibGVmdCIsInVwIiwicmlnaHQiLCJkb3duIiwic3BhY2ViYXIiLCJwYWdldXAiLCJwYWdlZG93biIsImVuZCIsImhvbWUiLCJpbml0VGVzdCIsImRpc2FibGVLZXlib2FyZCIsInJlbW92ZUV2ZW50Iiwia2V5ZG93biIsImFkZEV2ZW50IiwiaW5pdCIsImJvZHkiLCJodG1sIiwid2luZG93SGVpZ2h0Iiwid2luZG93IiwiaW5uZXJIZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJjb21wYXRNb2RlIiwiaW5kZXhPZiIsInRvcCIsInNlbGYiLCJvZmZzZXRIZWlnaHQiLCJzdHlsZSIsImhlaWdodCIsInNldFRpbWVvdXQiLCJyZWZyZXNoIiwidW5kZXJsYXkiLCJjcmVhdGVFbGVtZW50IiwiY2xlYXIiLCJhcHBlbmRDaGlsZCIsImJhY2tncm91bmRBdHRhY2htZW50IiwicXVlIiwicGVuZGluZyIsImxhc3RTY3JvbGwiLCJEYXRlIiwic2Nyb2xsQXJyYXkiLCJlbGVtIiwiZGVsYXkiLCJkaXJlY3Rpb25DaGVjayIsIm5vdyIsImVsYXBzZWQiLCJmYWN0b3IiLCJNYXRoIiwibWluIiwicHVzaCIsImxhc3RYIiwibGFzdFkiLCJzdGFydCIsInNjcm9sbFdpbmRvdyIsInN0ZXAiLCJ0aW1lIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJpIiwibGVuZ3RoIiwiaXRlbSIsImZpbmlzaGVkIiwicG9zaXRpb24iLCJwdWxzZSIsInNwbGljZSIsInNjcm9sbEJ5Iiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsInJlcXVlc3RGcmFtZSIsIndoZWVsIiwiZXZlbnQiLCJ0YXJnZXQiLCJvdmVyZmxvd2luZyIsIm92ZXJmbG93aW5nQW5jZXN0b3IiLCJkZWZhdWx0UHJldmVudGVkIiwiaXNOb2RlTmFtZSIsInRlc3QiLCJzcmMiLCJkZWx0YVgiLCJ3aGVlbERlbHRhWCIsImRlbHRhWSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YSIsImlzVG91Y2hwYWQiLCJhYnMiLCJwcmV2ZW50RGVmYXVsdCIsIm1vZGlmaWVyIiwiY3RybEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsImtleUNvZGUiLCJub2RlTmFtZSIsImlzQ29udGVudEVkaXRhYmxlIiwic2hpZnQiLCJjbGllbnRIZWlnaHQiLCJkYW10IiwibW91c2Vkb3duIiwiY2FjaGUiLCJzZXRJbnRlcnZhbCIsInVuaXF1ZUlEIiwiZWwiLCJzZXRDYWNoZSIsImVsZW1zIiwicm9vdFNjcm9sbEhlaWdodCIsImNhY2hlZCIsIm92ZXJmbG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJwYXJlbnROb2RlIiwidHlwZSIsImZuIiwiYnViYmxlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0YWciLCJ0b0xvd2VyQ2FzZSIsImRlbHRhQnVmZmVyVGltZXIiLCJjbGVhclRpbWVvdXQiLCJhbGxFcXVhbHMiLCJhbGxEaXZpc2FibGUiLCJpc0RpdmlzaWJsZSIsIm4iLCJkaXZpc29yIiwiZmxvb3IiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYWxsYmFjayIsImVsZW1lbnQiLCJwdWxzZV8iLCJ2YWwiLCJleHB4IiwiZXhwIiwiaXNDaHJvbWUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc01vdXNlV2hlZWxTdXBwb3J0ZWQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUMsWUFBVTs7QUFFWDtBQUNBLFFBQUlBLGlCQUFpQjs7QUFFakI7QUFDQUMsbUJBQW1CLEdBSEYsRUFHTztBQUN4QkMsdUJBQW1CLEdBSkYsRUFJTztBQUN4QkMsa0JBQW1CLEdBTEYsRUFLTzs7QUFFeEI7QUFDQTtBQUNBQyx3QkFBbUIsSUFURjtBQVVqQkMsb0JBQW1CLENBVkY7QUFXakJDLHdCQUFtQixDQVhGOztBQWFqQjtBQUNBQywyQkFBb0IsRUFkSCxFQWNRO0FBQ3pCQyx5QkFBb0IsQ0FmSCxFQWVROztBQUV6QjtBQUNBQyx5QkFBb0IsSUFsQkgsRUFrQlU7QUFDM0JDLHFCQUFvQixFQW5CSCxFQW1CVzs7QUFFNUI7QUFDQUMseUJBQW9CLElBdEJIO0FBdUJqQkMseUJBQW9CLElBdkJIO0FBd0JqQkMsa0JBQW9CO0FBeEJILEtBQXJCOztBQTJCQSxRQUFJQyxVQUFVZCxjQUFkOztBQUdBO0FBQ0EsUUFBSWUsYUFBYSxLQUFqQjtBQUNBLFFBQUlDLFVBQVUsS0FBZDtBQUNBLFFBQUlDLFlBQVksRUFBRUMsR0FBRyxDQUFMLEVBQVFDLEdBQUcsQ0FBWCxFQUFoQjtBQUNBLFFBQUlDLFdBQVksS0FBaEI7QUFDQSxRQUFJQyxPQUFPQyxTQUFTQyxlQUFwQjtBQUNBLFFBQUlDLGFBQUo7QUFDQSxRQUFJQyxRQUFKO0FBQ0EsUUFBSUMsY0FBYyxDQUFFLEdBQUYsRUFBTyxHQUFQLEVBQVksR0FBWixDQUFsQjs7QUFFQSxRQUFJQyxNQUFNLEVBQUVDLE1BQU0sRUFBUixFQUFZQyxJQUFJLEVBQWhCLEVBQW9CQyxPQUFP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LGtCQUFNOUUsUUFBUytFLFFBQVEsSUFBSS9FLEtBQVosQ0FBZjtBQUNIO0FBQ0QsZUFBTzhFLE1BQU0vSSxRQUFRUixjQUFyQjtBQUNIOztBQUVELGFBQVNvRixLQUFULENBQWV4RSxDQUFmLEVBQWtCO0FBQ2QsWUFBSUEsS0FBSyxDQUFULEVBQVksT0FBTyxDQUFQO0FBQ1osWUFBSUEsS0FBSyxDQUFULEVBQVksT0FBTyxDQUFQOztBQUVaLFlBQUlKLFFBQVFSLGNBQVIsSUFBMEIsQ0FBOUIsRUFBaUM7QUFDN0JRLG9CQUFRUixjQUFSLElBQTBCc0osT0FBTyxDQUFQLENBQTFCO0FBQ0g7QUFDRCxlQUFPQSxPQUFPMUksQ0FBUCxDQUFQO0FBQ0g7O0FBRUQsUUFBSThJLFdBQVcsVUFBVXpELElBQVYsQ0FBZXpELE9BQU9tSCxTQUFQLENBQWlCQyxTQUFoQyxDQUFmO0FBQ0EsUUFBSUMsd0JBQXdCLGtCQUFrQjdJLFFBQTlDOztBQUVBLFFBQUk2SSx5QkFBeUJILFFBQTdCLEVBQXVDO0FBQ3RDdkgsaUJBQVMsV0FBVCxFQUFzQm1GLFNBQXRCO0FBQ0FuRixpQkFBUyxZQUFULEVBQXVCdUQsS0FBdkI7QUFDQXZELGlCQUFTLE1BQVQsRUFBaUJDLElBQWpCO0FBQ0E7QUFFQSxDQW5nQkQiLCJmaWxlIjoiMTA2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gU21vb3RoU2Nyb2xsIGZvciB3ZWJzaXRlcyB2MS4yLjFcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUIGxpY2Vuc2UuXG5cbi8vIFBlb3BsZSBpbnZvbHZlZFxuLy8gIC0gQmFsYXpzIEdhbGFtYm9zaSAobWFpbnRhaW5lcikgIFxuLy8gIC0gTWljaGFlbCBIZXJmICAgICAoUHVsc2UgQWxnb3JpdGhtKVxuXG4oZnVuY3Rpb24oKXtcbiAgXG4vLyBTY3JvbGwgVmFyaWFibGVzICh0d2Vha2FibGUpXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG5cbiAgICAvLyBTY3JvbGxpbmcgQ29yZVxuICAgIGZyYW1lUmF0ZSAgICAgICAgOiAxNTAsIC8vIFtIel1cbiAgICBhbmltYXRpb25UaW1lICAgIDogNDAwLCAvLyBbcHhdXG4gICAgc3RlcFNpemUgICAgICAgICA6IDEyMCwgLy8gW3B4XVxuXG4gICAgLy8gUHVsc2UgKGxlc3MgdHdlYWthYmxlKVxuICAgIC8vIHJhdGlvIG9mIFwidGFpbFwiIHRvIFwiYWNjZWxlcmF0aW9uXCJcbiAgICBwdWxzZUFsZ29yaXRobSAgIDogdHJ1ZSxcbiAgICBwdWxzZVNjYWxlICAgICAgIDogOCxcbiAgICBwdWxzZU5vcm1hbGl6ZSAgIDogMSxcblxuICAgIC8vIEFjY2VsZXJhdGlvblxuICAgIGFjY2VsZXJhdGlvbkRlbHRhIDogMjAsICAvLyAyMFxuICAgIGFjY2VsZXJhdGlvbk1heCAgIDogMSwgICAvLyAxXG5cbiAgICAvLyBLZXlib2FyZCBTZXR0aW5nc1xuICAgIGtleWJvYXJkU3VwcG9ydCAgIDogdHJ1ZSwgIC8vIG9wdGlvblxuICAgIGFycm93U2Nyb2xsICAgICAgIDogNTAsICAgICAvLyBbcHhdXG5cbiAgICAvLyBPdGhlclxuICAgIHRvdWNocGFkU3VwcG9ydCAgIDogdHJ1ZSxcbiAgICBmaXhlZEJhY2tncm91bmQgICA6IHRydWUsIFxuICAgIGV4Y2x1ZGVkICAgICAgICAgIDogXCJcIiAgICBcbn07XG5cbnZhciBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG5cblxuLy8gT3RoZXIgVmFyaWFibGVzXG52YXIgaXNFeGNsdWRlZCA9IGZhbHNlO1xudmFyIGlzRnJhbWUgPSBmYWxzZTtcbnZhciBkaXJlY3Rpb24gPSB7IHg6IDAsIHk6IDAgfTtcbnZhciBpbml0RG9uZSAgPSBmYWxzZTtcbnZhciByb290ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xudmFyIGFjdGl2ZUVsZW1lbnQ7XG52YXIgb2JzZXJ2ZXI7XG52YXIgZGVsdGFCdWZmZXIgPSBbIDEyMCwgMTIwLCAxMjAgXTtcblxudmFyIGtleSA9IHsgbGVmdDogMzcsIHVwOiAzOCwgcmlnaHQ6IDM5LCBkb3duOiA0MCwgc3BhY2ViYXI6IDMyLCBcbiAgICAgICAgICAgIHBhZ2V1cDogMzMsIHBhZ2Vkb3duOiAzNCwgZW5kOiAzNSwgaG9tZTogMzYgfTtcblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFNFVFRJTkdTXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBJTklUSUFMSVpFXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICogVGVzdHMgaWYgc21vb3RoIHNjcm9sbGluZyBpcyBhbGxvd2VkLiBTaHV0cyBkb3duIGV2ZXJ5dGhpbmcgaWYgbm90LlxuICovXG5mdW5jdGlvbiBpbml0VGVzdCgpIHtcblxuICAgIHZhciBkaXNhYmxlS2V5Ym9hcmQgPSBmYWxzZTsgXG4gICAgXG4gICAgLy8gZGlzYWJsZSBrZXlib2FyZCBzdXBwb3J0IGlmIGFueXRoaW5nIGFib3ZlIHJlcXVlc3RlZCBpdFxuICAgIGlmIChkaXNhYmxlS2V5Ym9hcmQpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnQoXCJrZXlkb3duXCIsIGtleWRvd24pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmtleWJvYXJkU3VwcG9ydCAmJiAhZGlzYWJsZUtleWJvYXJkKSB7XG4gICAgICAgIGFkZEV2ZW50KFwia2V5ZG93blwiLCBrZXlkb3duKTtcbiAgICB9XG59XG5cbi8qKlxuICogU2V0cyB1cCBzY3JvbGxzIGFycmF5LCBkZXRlcm1pbmVzIGlmIGZyYW1lcyBhcmUgaW52b2x2ZWQuXG4gKi9cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIFxuICAgIGlmICghZG9jdW1lbnQuYm9keSkgcmV0dXJuO1xuXG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIHZhciBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7IFxuICAgIHZhciBzY3JvbGxIZWlnaHQgPSBib2R5LnNjcm9sbEhlaWdodDtcbiAgICBcbiAgICAvLyBjaGVjayBjb21wYXQgbW9kZSBmb3Igcm9vdCBlbGVtZW50XG4gICAgcm9vdCA9IChkb2N1bWVudC5jb21wYXRNb2RlLmluZGV4T2YoJ0NTUycpID49IDApID8gaHRtbCA6IGJvZHk7XG4gICAgYWN0aXZlRWxlbWVudCA9IGJvZHk7XG4gICAgXG4gICAgaW5pdFRlc3QoKTtcbiAgICBpbml0RG9uZSA9IHRydWU7XG5cbiAgICAvLyBDaGVja3MgaWYgdGhpcyBzY3JpcHQgaXMgcnVubmluZyBpbiBhIGZyYW1lXG4gICAgaWYgKHRvcCAhPSBzZWxmKSB7XG4gICAgICAgIGlzRnJhbWUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZml4ZXMgYSBidWcgd2hlcmUgdGhlIGFyZWFzIGxlZnQgYW5kIHJpZ2h0IHRvIFxuICAgICAqIHRoZSBjb250ZW50IGRvZXMgbm90IHRyaWdnZXIgdGhlIG9ubW91c2V3aGVlbCBldmVudFxuICAgICAqIG9uIHNvbWUgcGFnZXMuIGUuZy46IGh0bWwsIGJvZHkgeyBoZWlnaHQ6IDEwMCUgfVxuICAgICAqL1xuICAgIGVsc2UgaWYgKHNjcm9sbEhlaWdodCA+IHdpbmRvd0hlaWdodCAmJlxuICAgICAgICAgICAgKGJvZHkub2Zmc2V0SGVpZ2h0IDw9IHdpbmRvd0hlaWdodCB8fCBcbiAgICAgICAgICAgICBodG1sLm9mZnNldEhlaWdodCA8PSB3aW5kb3dIZWlnaHQpKSB7XG5cbiAgICAgICAgaHRtbC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAgIHNldFRpbWVvdXQocmVmcmVzaCwgMTApO1xuXG4gICAgICAgIC8vIGNsZWFyZml4XG4gICAgICAgIGlmIChyb290Lm9mZnNldEhlaWdodCA8PSB3aW5kb3dIZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciB1bmRlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7IFx0XG4gICAgICAgICAgICB1bmRlcmxheS5zdHlsZS5jbGVhciA9IFwiYm90aFwiO1xuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZCh1bmRlcmxheSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkaXNhYmxlIGZpeGVkIGJhY2tncm91bmRcbiAgICBpZiAoIW9wdGlvbnMuZml4ZWRCYWNrZ3JvdW5kICYmICFpc0V4Y2x1ZGVkKSB7XG4gICAgICAgIGJvZHkuc3R5bGUuYmFja2dyb3VuZEF0dGFjaG1lbnQgPSBcInNjcm9sbFwiO1xuICAgICAgICBodG1sLnN0eWxlLmJhY2tncm91bmRBdHRhY2htZW50ID0gXCJzY3JvbGxcIjtcbiAgICB9XG59XG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogU0NST0xMSU5HIFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiBcbnZhciBxdWUgPSBbXTtcbnZhciBwZW5kaW5nID0gZmFsc2U7XG52YXIgbGFzdFNjcm9sbCA9ICtuZXcgRGF0ZTtcblxuLyoqXG4gKiBQdXNoZXMgc2Nyb2xsIGFjdGlvbnMgdG8gdGhlIHNjcm9sbGluZyBxdWV1ZS5cbiAqL1xuZnVuY3Rpb24gc2Nyb2xsQXJyYXkoZWxlbSwgbGVmdCwgdG9wLCBkZWxheSkge1xuICAgIFxuICAgIGRlbGF5IHx8IChkZWxheSA9IDEwMDApO1xuICAgIGRpcmVjdGlvbkNoZWNrKGxlZnQsIHRvcCk7XG5cbiAgICBpZiAob3B0aW9ucy5hY2NlbGVyYXRpb25NYXggIT0gMSkge1xuICAgICAgICB2YXIgbm93ID0gK25ldyBEYXRlO1xuICAgICAgICB2YXIgZWxhcHNlZCA9IG5vdyAtIGxhc3RTY3JvbGw7XG4gICAgICAgIGlmIChlbGFwc2VkIDwgb3B0aW9ucy5hY2NlbGVyYXRpb25EZWx0YSkge1xuICAgICAgICAgICAgdmFyIGZhY3RvciA9ICgxICsgKDMwIC8gZWxhcHNlZCkpIC8gMjtcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPiAxKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yID0gTWF0aC5taW4oZmFjdG9yLCBvcHRpb25zLmFjY2VsZXJhdGlvbk1heCk7XG4gICAgICAgICAgICAgICAgbGVmdCAqPSBmYWN0b3I7XG4gICAgICAgICAgICAgICAgdG9wICAqPSBmYWN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFNjcm9sbCA9ICtuZXcgRGF0ZTtcbiAgICB9ICAgICAgICAgIFxuICAgIFxuICAgIC8vIHB1c2ggYSBzY3JvbGwgY29tbWFuZFxuICAgIHF1ZS5wdXNoKHtcbiAgICAgICAgeDogbGVmdCwgXG4gICAgICAgIHk6IHRvcCwgXG4gICAgICAgIGxhc3RYOiAobGVmdCA8IDApID8gMC45OSA6IC0wLjk5LFxuICAgICAgICBsYXN0WTogKHRvcCAgPCAwKSA/IDAuOTkgOiAtMC45OSwgXG4gICAgICAgIHN0YXJ0OiArbmV3IERhdGVcbiAgICB9KTtcbiAgICAgICAgXG4gICAgLy8gZG9uJ3QgYWN0IGlmIHRoZXJlJ3MgYSBwZW5kaW5nIHF1ZXVlXG4gICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gIFxuXG4gICAgdmFyIHNjcm9sbFdpbmRvdyA9IChlbGVtID09PSBkb2N1bWVudC5ib2R5KTtcbiAgICBcbiAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgbm93ID0gK25ldyBEYXRlO1xuICAgICAgICB2YXIgc2Nyb2xsWCA9IDA7XG4gICAgICAgIHZhciBzY3JvbGxZID0gMDsgXG4gICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBpdGVtID0gcXVlW2ldO1xuICAgICAgICAgICAgdmFyIGVsYXBzZWQgID0gbm93IC0gaXRlbS5zdGFydDtcbiAgICAgICAgICAgIHZhciBmaW5pc2hlZCA9IChlbGFwc2VkID49IG9wdGlvbnMuYW5pbWF0aW9uVGltZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHNjcm9sbCBwb3NpdGlvbjogWzAsIDFdXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSAoZmluaXNoZWQpID8gMSA6IGVsYXBzZWQgLyBvcHRpb25zLmFuaW1hdGlvblRpbWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGVhc2luZyBbb3B0aW9uYWxdXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wdWxzZUFsZ29yaXRobSkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gcHVsc2UocG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBvbmx5IG5lZWQgdGhlIGRpZmZlcmVuY2VcbiAgICAgICAgICAgIHZhciB4ID0gKGl0ZW0ueCAqIHBvc2l0aW9uIC0gaXRlbS5sYXN0WCkgPj4gMDtcbiAgICAgICAgICAgIHZhciB5ID0gKGl0ZW0ueSAqIHBvc2l0aW9uIC0gaXRlbS5sYXN0WSkgPj4gMDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gYWRkIHRoaXMgdG8gdGhlIHRvdGFsIHNjcm9sbGluZ1xuICAgICAgICAgICAgc2Nyb2xsWCArPSB4O1xuICAgICAgICAgICAgc2Nyb2xsWSArPSB5OyAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyB1cGRhdGUgbGFzdCB2YWx1ZXNcbiAgICAgICAgICAgIGl0ZW0ubGFzdFggKz0geDtcbiAgICAgICAgICAgIGl0ZW0ubGFzdFkgKz0geTtcbiAgICAgICAgXG4gICAgICAgICAgICAvLyBkZWxldGUgYW5kIHN0ZXAgYmFjayBpZiBpdCdzIG92ZXJcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHF1ZS5zcGxpY2UoaSwgMSk7IGktLTtcbiAgICAgICAgICAgIH0gICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2Nyb2xsIGxlZnQgYW5kIHRvcFxuICAgICAgICBpZiAoc2Nyb2xsV2luZG93KSB7XG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsQnkoc2Nyb2xsWCwgc2Nyb2xsWSk7XG4gICAgICAgIH0gXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNjcm9sbFgpIGVsZW0uc2Nyb2xsTGVmdCArPSBzY3JvbGxYO1xuICAgICAgICAgICAgaWYgKHNjcm9sbFkpIGVsZW0uc2Nyb2xsVG9wICArPSBzY3JvbGxZOyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIGNsZWFuIHVwIGlmIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvXG4gICAgICAgIGlmICghbGVmdCAmJiAhdG9wKSB7XG4gICAgICAgICAgICBxdWUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHF1ZS5sZW5ndGgpIHsgXG4gICAgICAgICAgICByZXF1ZXN0RnJhbWUoc3RlcCwgZWxlbSwgKGRlbGF5IC8gb3B0aW9ucy5mcmFtZVJhdGUgKyAxKSk7IFxuICAgICAgICB9IGVsc2UgeyBcbiAgICAgICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gc3RhcnQgYSBuZXcgcXVldWUgb2YgYWN0aW9uc1xuICAgIHJlcXVlc3RGcmFtZShzdGVwLCBlbGVtLCAwKTtcbiAgICBwZW5kaW5nID0gdHJ1ZTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEVWRU5UU1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAqIE1vdXNlIHdoZWVsIGhhbmRsZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gd2hlZWwoZXZlbnQpIHtcblxuICAgIGlmICghaW5pdERvbmUpIHtcbiAgICAgICAgaW5pdCgpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIHZhciBvdmVyZmxvd2luZyA9IG92ZXJmbG93aW5nQW5jZXN0b3IodGFyZ2V0KTtcbiAgICBcbiAgICAvLyB1c2UgZGVmYXVsdCBpZiB0aGVyZSdzIG5vIG92ZXJmbG93aW5nXG4gICAgLy8gZWxlbWVudCBvciBkZWZhdWx0IGFjdGlvbiBpcyBwcmV2ZW50ZWQgICAgXG4gICAgaWYgKCFvdmVyZmxvd2luZyB8fCBldmVudC5kZWZhdWx0UHJldmVudGVkIHx8XG4gICAgICAgIGlzTm9kZU5hbWUoYWN0aXZlRWxlbWVudCwgXCJlbWJlZFwiKSB8fFxuICAgICAgIChpc05vZGVOYW1lKHRhcmdldCwgXCJlbWJlZFwiKSAmJiAvXFwucGRmL2kudGVzdCh0YXJnZXQuc3JjKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGRlbHRhWCA9IGV2ZW50LndoZWVsRGVsdGFYIHx8IDA7XG4gICAgdmFyIGRlbHRhWSA9IGV2ZW50LndoZWVsRGVsdGFZIHx8IDA7XG4gICAgXG4gICAgLy8gdXNlIHdoZWVsRGVsdGEgaWYgZGVsdGFYL1kgaXMgbm90IGF2YWlsYWJsZVxuICAgIGlmICghZGVsdGFYICYmICFkZWx0YVkpIHtcbiAgICAgICAgZGVsdGFZID0gZXZlbnQud2hlZWxEZWx0YSB8fCAwO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGl0J3MgYSB0b3VjaHBhZCBzY3JvbGwgdGhhdCBzaG91bGQgYmUgaWdub3JlZFxuICAgIGlmICghb3B0aW9ucy50b3VjaHBhZFN1cHBvcnQgJiYgaXNUb3VjaHBhZChkZWx0YVkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIHNjYWxlIGJ5IHN0ZXAgc2l6ZVxuICAgIC8vIGRlbHRhIGlzIDEyMCBtb3N0IG9mIHRoZSB0aW1lXG4gICAgLy8gc3luYXB0aWNzIHNlZW1zIHRvIHNlbmQgMSBzb21ldGltZXNcbiAgICBpZiAoTWF0aC5hYnMoZGVsdGFYKSA+IDEuMikge1xuICAgICAgICBkZWx0YVggKj0gb3B0aW9ucy5zdGVwU2l6ZSAvIDEyMDtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKGRlbHRhWSkgPiAxLjIpIHtcbiAgICAgICAgZGVsdGFZICo9IG9wdGlvbnMuc3RlcFNpemUgLyAxMjA7XG4gICAgfVxuICAgIFxuICAgIHNjcm9sbEFycmF5KG92ZXJmbG93aW5nLCAtZGVsdGFYLCAtZGVsdGFZKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG4vKipcbiAqIEtleWRvd24gZXZlbnQgaGFuZGxlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICovXG5mdW5jdGlvbiBrZXlkb3duKGV2ZW50KSB7XG5cbiAgICB2YXIgdGFyZ2V0ICAgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIG1vZGlmaWVyID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBcbiAgICAgICAgICAgICAgICAgIChldmVudC5zaGlmdEtleSAmJiBldmVudC5rZXlDb2RlICE9PSBrZXkuc3BhY2ViYXIpO1xuICAgIFxuICAgIC8vIGRvIG5vdGhpbmcgaWYgdXNlciBpcyBlZGl0aW5nIHRleHRcbiAgICAvLyBvciB1c2luZyBhIG1vZGlmaWVyIGtleSAoZXhjZXB0IHNoaWZ0KVxuICAgIC8vIG9yIGluIGEgZHJvcGRvd25cbiAgICBpZiAoIC9pbnB1dHx0ZXh0YXJlYXxzZWxlY3R8ZW1iZWQvaS50ZXN0KHRhcmdldC5ub2RlTmFtZSkgfHxcbiAgICAgICAgIHRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZSB8fCBcbiAgICAgICAgIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgICB8fFxuICAgICAgICAgbW9kaWZpZXIgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gc3BhY2ViYXIgc2hvdWxkIHRyaWdnZXIgYnV0dG9uIHByZXNzXG4gICAgaWYgKGlzTm9kZU5hbWUodGFyZ2V0LCBcImJ1dHRvblwiKSAmJlxuICAgICAgICBldmVudC5rZXlDb2RlID09PSBrZXkuc3BhY2ViYXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICB2YXIgc2hpZnQsIHggPSAwLCB5ID0gMDtcbiAgICB2YXIgZWxlbSA9IG92ZXJmbG93aW5nQW5jZXN0b3IoYWN0aXZlRWxlbWVudCk7XG4gICAgdmFyIGNsaWVudEhlaWdodCA9IGVsZW0uY2xpZW50SGVpZ2h0O1xuXG4gICAgaWYgKGVsZW0gPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBjbGllbnRIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfVxuXG4gICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2Uga2V5LnVwOlxuICAgICAgICAgICAgeSA9IC1vcHRpb25zLmFycm93U2Nyb2xsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Uga2V5LmRvd246XG4gICAgICAgICAgICB5ID0gb3B0aW9ucy5hcnJvd1Njcm9sbDtcbiAgICAgICAgICAgIGJyZWFrOyAgICAgICAgIFxuICAgICAgICBjYXNlIGtleS5zcGFjZWJhcjogLy8gKCsgc2hpZnQpXG4gICAgICAgICAgICBzaGlmdCA9IGV2ZW50LnNoaWZ0S2V5ID8gMSA6IC0xO1xuICAgICAgICAgICAgeSA9IC1zaGlmdCAqIGNsaWVudEhlaWdodCAqIDAuOTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGtleS5wYWdldXA6XG4gICAgICAgICAgICB5ID0gLWNsaWVudEhlaWdodCAqIDAuOTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGtleS5wYWdlZG93bjpcbiAgICAgICAgICAgIHkgPSBjbGllbnRIZWlnaHQgKiAwLjk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBrZXkuaG9tZTpcbiAgICAgICAgICAgIHkgPSAtZWxlbS5zY3JvbGxUb3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBrZXkuZW5kOlxuICAgICAgICAgICAgdmFyIGRhbXQgPSBlbGVtLnNjcm9sbEhlaWdodCAtIGVsZW0uc2Nyb2xsVG9wIC0gY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgeSA9IChkYW10ID4gMCkgPyBkYW10KzEwIDogMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGtleS5sZWZ0OlxuICAgICAgICAgICAgeCA9IC1vcHRpb25zLmFycm93U2Nyb2xsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Uga2V5LnJpZ2h0OlxuICAgICAgICAgICAgeCA9IG9wdGlvbnMuYXJyb3dTY3JvbGw7XG4gICAgICAgICAgICBicmVhazsgICAgICAgICAgICBcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBhIGtleSB3ZSBkb24ndCBjYXJlIGFib3V0XG4gICAgfVxuXG4gICAgc2Nyb2xsQXJyYXkoZWxlbSwgeCwgeSk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuLyoqXG4gKiBNb3VzZWRvd24gZXZlbnQgb25seSBmb3IgdXBkYXRpbmcgYWN0aXZlRWxlbWVudFxuICovXG5mdW5jdGlvbiBtb3VzZWRvd24oZXZlbnQpIHtcbiAgICBhY3RpdmVFbGVtZW50ID0gZXZlbnQudGFyZ2V0O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogT1ZFUkZMT1dcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiBcbnZhciBjYWNoZSA9IHt9OyAvLyBjbGVhcmVkIG91dCBldmVyeSBvbmNlIGluIHdoaWxlXG5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IGNhY2hlID0ge307IH0sIDEwICogMTAwMCk7XG5cbnZhciB1bmlxdWVJRCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIGVsLnVuaXF1ZUlEIHx8IChlbC51bmlxdWVJRCA9IGkrKyk7XG4gICAgfTtcbn0pKCk7XG5cbmZ1bmN0aW9uIHNldENhY2hlKGVsZW1zLCBvdmVyZmxvd2luZykge1xuICAgIGZvciAodmFyIGkgPSBlbGVtcy5sZW5ndGg7IGktLTspXG4gICAgICAgIGNhY2hlW3VuaXF1ZUlEKGVsZW1zW2ldKV0gPSBvdmVyZmxvd2luZztcbiAgICByZXR1cm4gb3ZlcmZsb3dpbmc7XG59XG5cbmZ1bmN0aW9uIG92ZXJmbG93aW5nQW5jZXN0b3IoZWwpIHtcbiAgICB2YXIgZWxlbXMgPSBbXTtcbiAgICB2YXIgcm9vdFNjcm9sbEhlaWdodCA9IHJvb3Quc2Nyb2xsSGVpZ2h0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGNhY2hlZCA9IGNhY2hlW3VuaXF1ZUlEKGVsKV07XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRDYWNoZShlbGVtcywgY2FjaGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtcy5wdXNoKGVsKTtcbiAgICAgICAgaWYgKHJvb3RTY3JvbGxIZWlnaHQgPT09IGVsLnNjcm9sbEhlaWdodCkge1xuICAgICAgICAgICAgaWYgKCFpc0ZyYW1lIHx8IHJvb3QuY2xpZW50SGVpZ2h0ICsgMTAgPCByb290U2Nyb2xsSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldENhY2hlKGVsZW1zLCBkb2N1bWVudC5ib2R5KTsgLy8gc2Nyb2xsaW5nIHJvb3QgaW4gV2ViS2l0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZWwuY2xpZW50SGVpZ2h0ICsgMTAgPCBlbC5zY3JvbGxIZWlnaHQpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCwgXCJcIikuZ2V0UHJvcGVydHlWYWx1ZShcIm92ZXJmbG93LXlcIik7XG4gICAgICAgICAgICBpZiAob3ZlcmZsb3cgPT09IFwic2Nyb2xsXCIgfHwgb3ZlcmZsb3cgPT09IFwiYXV0b1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldENhY2hlKGVsZW1zLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChlbCA9IGVsLnBhcmVudE5vZGUpO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogSEVMUEVSU1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5mdW5jdGlvbiBhZGRFdmVudCh0eXBlLCBmbiwgYnViYmxlKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIChidWJibGV8fGZhbHNlKSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50KHR5cGUsIGZuLCBidWJibGUpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgKGJ1YmJsZXx8ZmFsc2UpKTsgIFxufVxuXG5mdW5jdGlvbiBpc05vZGVOYW1lKGVsLCB0YWcpIHtcbiAgICByZXR1cm4gKGVsLm5vZGVOYW1lfHxcIlwiKS50b0xvd2VyQ2FzZSgpID09PSB0YWcudG9Mb3dlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gZGlyZWN0aW9uQ2hlY2soeCwgeSkge1xuICAgIHggPSAoeCA+IDApID8gMSA6IC0xO1xuICAgIHkgPSAoeSA+IDApID8gMSA6IC0xO1xuICAgIGlmIChkaXJlY3Rpb24ueCAhPT0geCB8fCBkaXJlY3Rpb24ueSAhPT0geSkge1xuICAgICAgICBkaXJlY3Rpb24ueCA9IHg7XG4gICAgICAgIGRpcmVjdGlvbi55ID0geTtcbiAgICAgICAgcXVlID0gW107XG4gICAgICAgIGxhc3RTY3JvbGwgPSAwO1xuICAgIH1cbn1cblxudmFyIGRlbHRhQnVmZmVyVGltZXI7XG5cbmZ1bmN0aW9uIGlzVG91Y2hwYWQoZGVsdGFZKSB7XG4gICAgaWYgKCFkZWx0YVkpIHJldHVybjtcbiAgICBkZWx0YVkgPSBNYXRoLmFicyhkZWx0YVkpXG4gICAgZGVsdGFCdWZmZXIucHVzaChkZWx0YVkpO1xuICAgIGRlbHRhQnVmZmVyLnNoaWZ0KCk7XG4gICAgY2xlYXJUaW1lb3V0KGRlbHRhQnVmZmVyVGltZXIpO1xuXG4gICAgdmFyIGFsbEVxdWFscyAgICA9IChkZWx0YUJ1ZmZlclswXSA9PSBkZWx0YUJ1ZmZlclsxXSAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhQnVmZmVyWzFdID09IGRlbHRhQnVmZmVyWzJdKTtcbiAgICB2YXIgYWxsRGl2aXNhYmxlID0gKGlzRGl2aXNpYmxlKGRlbHRhQnVmZmVyWzBdLCAxMjApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RpdmlzaWJsZShkZWx0YUJ1ZmZlclsxXSwgMTIwKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEaXZpc2libGUoZGVsdGFCdWZmZXJbMl0sIDEyMCkpO1xuICAgIHJldHVybiAhKGFsbEVxdWFscyB8fCBhbGxEaXZpc2FibGUpO1xufSBcblxuZnVuY3Rpb24gaXNEaXZpc2libGUobiwgZGl2aXNvcikge1xuICAgIHJldHVybiAoTWF0aC5mbG9vcihuIC8gZGl2aXNvcikgPT0gbiAvIGRpdmlzb3IpO1xufVxuXG52YXIgcmVxdWVzdEZyYW1lID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgICB8fCBcbiAgICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGNhbGxiYWNrLCBlbGVtZW50LCBkZWxheSkge1xuICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5IHx8ICgxMDAwLzYwKSk7XG4gICAgICAgICAgICAgIH07XG59KSgpO1xuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogUFVMU0VcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiBcbi8qKlxuICogVmlzY291cyBmbHVpZCB3aXRoIGEgcHVsc2UgZm9yIHBhcnQgYW5kIGRlY2F5IGZvciB0aGUgcmVzdC5cbiAqIC0gQXBwbGllcyBhIGZpeGVkIGZvcmNlIG92ZXIgYW4gaW50ZXJ2YWwgKGEgZGFtcGVkIGFjY2VsZXJhdGlvbiksIGFuZFxuICogLSBMZXRzIHRoZSBleHBvbmVudGlhbCBibGVlZCBhd2F5IHRoZSB2ZWxvY2l0eSBvdmVyIGEgbG9uZ2VyIGludGVydmFsXG4gKiAtIE1pY2hhZWwgSGVyZiwgaHR0cDovL3N0ZXJlb3BzaXMuY29tL3N0b3BwaW5nL1xuICovXG5mdW5jdGlvbiBwdWxzZV8oeCkge1xuICAgIHZhciB2YWwsIHN0YXJ0LCBleHB4O1xuICAgIC8vIHRlc3RcbiAgICB4ID0geCAqIG9wdGlvbnMucHVsc2VTY2FsZTtcbiAgICBpZiAoeCA8IDEpIHsgLy8gYWNjZWxlYXJ0aW9uXG4gICAgICAgIHZhbCA9IHggLSAoMSAtIE1hdGguZXhwKC14KSk7XG4gICAgfSBlbHNlIHsgICAgIC8vIHRhaWxcbiAgICAgICAgLy8gdGhlIHByZXZpb3VzIGFuaW1hdGlvbiBlbmRlZCBoZXJlOlxuICAgICAgICBzdGFydCA9IE1hdGguZXhwKC0xKTtcbiAgICAgICAgLy8gc2ltcGxlIHZpc2NvdXMgZHJhZ1xuICAgICAgICB4IC09IDE7XG4gICAgICAgIGV4cHggPSAxIC0gTWF0aC5leHAoLXgpO1xuICAgICAgICB2YWwgPSBzdGFydCArIChleHB4ICogKDEgLSBzdGFydCkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsICogb3B0aW9ucy5wdWxzZU5vcm1hbGl6ZTtcbn1cblxuZnVuY3Rpb24gcHVsc2UoeCkge1xuICAgIGlmICh4ID49IDEpIHJldHVybiAxO1xuICAgIGlmICh4IDw9IDApIHJldHVybiAwO1xuXG4gICAgaWYgKG9wdGlvbnMucHVsc2VOb3JtYWxpemUgPT0gMSkge1xuICAgICAgICBvcHRpb25zLnB1bHNlTm9ybWFsaXplIC89IHB1bHNlXygxKTtcbiAgICB9XG4gICAgcmV0dXJuIHB1bHNlXyh4KTtcbn1cblxudmFyIGlzQ2hyb21lID0gL2Nocm9tZS9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIGlzTW91c2VXaGVlbFN1cHBvcnRlZCA9ICdvbm1vdXNld2hlZWwnIGluIGRvY3VtZW50OyBcblxuaWYgKGlzTW91c2VXaGVlbFN1cHBvcnRlZCAmJiBpc0Nocm9tZSkge1xuXHRhZGRFdmVudChcIm1vdXNlZG93blwiLCBtb3VzZWRvd24pO1xuXHRhZGRFdmVudChcIm1vdXNld2hlZWxcIiwgd2hlZWwpO1xuXHRhZGRFdmVudChcImxvYWRcIiwgaW5pdCk7XG59O1xuXG59KSgpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvd3d3L2pzL1Ntb290aFNjcm9sbC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///106\n");

/***/ })

/******/ });