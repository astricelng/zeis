/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 89);
/******/ })
/************************************************************************/
/******/ ({

/***/ 89:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(90);


/***/ }),

/***/ 90:
/***/ (function(module, exports) {

eval("// SmoothScroll for websites v1.2.1\n// Licensed under the terms of the MIT license.\n\n// People involved\n//  - Balazs Galambosi (maintainer)  \n//  - Michael Herf     (Pulse Algorithm)\n\n(function () {\n\n    // Scroll Variables (tweakable)\n    var defaultOptions = {\n\n        // Scrolling Core\n        frameRate: 150, // [Hz]\n        animationTime: 400, // [px]\n        stepSize: 120, // [px]\n\n        // Pulse (less tweakable)\n        // ratio of \"tail\" to \"acceleration\"\n        pulseAlgorithm: true,\n        pulseScale: 8,\n        pulseNormalize: 1,\n\n        // Acceleration\n        accelerationDelta: 20, // 20\n        accelerationMax: 1, // 1\n\n        // Keyboard Settings\n        keyboardSupport: true, // option\n        arrowScroll: 50, // [px]\n\n        // Other\n        touchpadSupport: true,\n        fixedBackground: true,\n        excluded: \"\"\n    };\n\n    var options = defaultOptions;\n\n    // Other Variables\n    var isExcluded = false;\n    var isFrame = false;\n    var direction = { x: 0, y: 0 };\n    var initDone = false;\n    var root = document.documentElement;\n    var activeElement;\n    var observer;\n    var deltaBuffer = [120, 120, 120];\n\n    var key = { left: 37, up: 38, right: 39, down: 40, spacebar: 32,\n        pageup: 33, pagedown: 34, end: 35, home: 36 };\n\n    /***********************************************\n     * SETTINGS\n     ***********************************************/\n\n    var options = defaultOptions;\n\n    /***********************************************\n     * INITIALIZE\n     ***********************************************/\n\n    /**\n     * Tests if smooth scrolling is allowed. Shuts down everything if not.\n     */\n    function initTest() {\n\n        var disableKeyboard = false;\n\n        // disable keyboard support if anything above requested it\n        if (disableKeyboard) {\n            removeEvent(\"keydown\", keydown);\n        }\n\n        if (options.keyboardSupport && !disableKeyboard) {\n            addEvent(\"keydown\", keydown);\n        }\n    }\n\n    /**\n     * Sets up scrolls array, determines if frames are involved.\n     */\n    function init() {\n\n        if (!document.body) return;\n\n        var body = document.body;\n        var html = document.documentElement;\n        var windowHeight = window.innerHeight;\n        var scrollHeight = body.scrollHeight;\n\n        // check compat mode for root element\n        root = document.compatMode.indexOf('CSS') >= 0 ? html : body;\n        activeElement = body;\n\n        initTest();\n        initDone = true;\n\n        // Checks if this script is running in a frame\n        if (top != self) {\n            isFrame = true;\n        }\n\n        /**\n         * This fixes a bug where the areas left and right to \n         * the content does not trigger the onmousewheel event\n         * on some pages. e.g.: html, body { height: 100% }\n         */\n        else if (scrollHeight > windowHeight && (body.offsetHeight <= windowHeight || html.offsetHeight <= windowHeight)) {\n\n                html.style.height = 'auto';\n                setTimeout(refresh, 10);\n\n                // clearfix\n                if (root.offsetHeight <= windowHeight) {\n                    var underlay = document.createElement(\"div\");\n                    underlay.style.clear = \"both\";\n                    body.appendChild(underlay);\n                }\n            }\n\n        // disable fixed background\n        if (!options.fixedBackground && !isExcluded) {\n            body.style.backgroundAttachment = \"scroll\";\n            html.style.backgroundAttachment = \"scroll\";\n        }\n    }\n\n    /************************************************\n     * SCROLLING \n     ************************************************/\n\n    var que = [];\n    var pending = false;\n    var lastScroll = +new Date();\n\n    /**\n     * Pushes scroll actions to the scrolling queue.\n     */\n    function scrollArray(elem, left, top, delay) {\n\n        delay || (delay = 1000);\n        directionCheck(left, top);\n\n        if (options.accelerationMax != 1) {\n            var now = +new Date();\n            var elapsed = now - lastScroll;\n            if (elapsed < options.accelerationDelta) {\n                var factor = (1 + 30 / elapsed) / 2;\n                if (factor > 1) {\n                    factor = Math.min(factor, options.accelerationMax);\n                    left *= factor;\n                    top *= factor;\n                }\n            }\n            lastScroll = +new Date();\n        }\n\n        // push a scroll command\n        que.push({\n            x: left,\n            y: top,\n            lastX: left < 0 ? 0.99 : -0.99,\n            lastY: top < 0 ? 0.99 : -0.99,\n            start: +new Date()\n        });\n\n        // don't act if there's a pending queue\n        if (pending) {\n            return;\n        }\n\n        var scrollWindow = elem === document.body;\n\n        var step = function step(time) {\n\n            var now = +new Date();\n            var scrollX = 0;\n            var scrollY = 0;\n\n            for (var i = 0; i < que.length; i++) {\n\n                var item = que[i];\n                var elapsed = now - item.start;\n                var finished = elapsed >= options.animationTime;\n\n                // scroll position: [0, 1]\n                var position = finished ? 1 : elapsed / options.animationTime;\n\n                // easing [optional]\n                if (options.pulseAlgorithm) {\n                    position = pulse(position);\n                }\n\n                // only need the difference\n                var x = item.x * position - item.lastX >> 0;\n                var y = item.y * position - item.lastY >> 0;\n\n                // add this to the total scrolling\n                scrollX += x;\n                scrollY += y;\n\n                // update last values\n                item.lastX += x;\n                item.lastY += y;\n\n                // delete and step back if it's over\n                if (finished) {\n                    que.splice(i, 1);i--;\n                }\n            }\n\n            // scroll left and top\n            if (scrollWindow) {\n                window.scrollBy(scrollX, scrollY);\n            } else {\n                if (scrollX) elem.scrollLeft += scrollX;\n                if (scrollY) elem.scrollTop += scrollY;\n            }\n\n            // clean up if there's nothing left to do\n            if (!left && !top) {\n                que = [];\n            }\n\n            if (que.length) {\n                requestFrame(step, elem, delay / options.frameRate + 1);\n            } else {\n                pending = false;\n            }\n        };\n\n        // start a new queue of actions\n        requestFrame(step, elem, 0);\n        pending = true;\n    }\n\n    /***********************************************\n     * EVENTS\n     ***********************************************/\n\n    /**\n     * Mouse wheel handler.\n     * @param {Object} event\n     */\n    function wheel(event) {\n\n        if (!initDone) {\n            init();\n        }\n\n        var target = event.target;\n        var overflowing = overflowingAncestor(target);\n\n        // use default if there's no overflowing\n        // element or default action is prevented    \n        if (!overflowing || event.defaultPrevented || isNodeName(activeElement, \"embed\") || isNodeName(target, \"embed\") && /\\.pdf/i.test(target.src)) {\n            return true;\n        }\n\n        var deltaX = event.wheelDeltaX || 0;\n        var deltaY = event.wheelDeltaY || 0;\n\n        // use wheelDelta if deltaX/Y is not available\n        if (!deltaX && !deltaY) {\n            deltaY = event.wheelDelta || 0;\n        }\n\n        // check if it's a touchpad scroll that should be ignored\n        if (!options.touchpadSupport && isTouchpad(deltaY)) {\n            return true;\n        }\n\n        // scale by step size\n        // delta is 120 most of the time\n        // synaptics seems to send 1 sometimes\n        if (Math.abs(deltaX) > 1.2) {\n            deltaX *= options.stepSize / 120;\n        }\n        if (Math.abs(deltaY) > 1.2) {\n            deltaY *= options.stepSize / 120;\n        }\n\n        scrollArray(overflowing, -deltaX, -deltaY);\n        event.preventDefault();\n    }\n\n    /**\n     * Keydown event handler.\n     * @param {Object} event\n     */\n    function keydown(event) {\n\n        var target = event.target;\n        var modifier = event.ctrlKey || event.altKey || event.metaKey || event.shiftKey && event.keyCode !== key.spacebar;\n\n        // do nothing if user is editing text\n        // or using a modifier key (except shift)\n        // or in a dropdown\n        if (/input|textarea|select|embed/i.test(target.nodeName) || target.isContentEditable || event.defaultPrevented || modifier) {\n            return true;\n        }\n        // spacebar should trigger button press\n        if (isNodeName(target, \"button\") && event.keyCode === key.spacebar) {\n            return true;\n        }\n\n        var shift,\n            x = 0,\n            y = 0;\n        var elem = overflowingAncestor(activeElement);\n        var clientHeight = elem.clientHeight;\n\n        if (elem == document.body) {\n            clientHeight = window.innerHeight;\n        }\n\n        switch (event.keyCode) {\n            case key.up:\n                y = -options.arrowScroll;\n                break;\n            case key.down:\n                y = options.arrowScroll;\n                break;\n            case key.spacebar:\n                // (+ shift)\n                shift = event.shiftKey ? 1 : -1;\n                y = -shift * clientHeight * 0.9;\n                break;\n            case key.pageup:\n                y = -clientHeight * 0.9;\n                break;\n            case key.pagedown:\n                y = clientHeight * 0.9;\n                break;\n            case key.home:\n                y = -elem.scrollTop;\n                break;\n            case key.end:\n                var damt = elem.scrollHeight - elem.scrollTop - clientHeight;\n                y = damt > 0 ? damt + 10 : 0;\n                break;\n            case key.left:\n                x = -options.arrowScroll;\n                break;\n            case key.right:\n                x = options.arrowScroll;\n                break;\n            default:\n                return true; // a key we don't care about\n        }\n\n        scrollArray(elem, x, y);\n        event.preventDefault();\n    }\n\n    /**\n     * Mousedown event only for updating activeElement\n     */\n    function mousedown(event) {\n        activeElement = event.target;\n    }\n\n    /***********************************************\n     * OVERFLOW\n     ***********************************************/\n\n    var cache = {}; // cleared out every once in while\n    setInterval(function () {\n        cache = {};\n    }, 10 * 1000);\n\n    var uniqueID = function () {\n        var i = 0;\n        return function (el) {\n            return el.uniqueID || (el.uniqueID = i++);\n        };\n    }();\n\n    function setCache(elems, overflowing) {\n        for (var i = elems.length; i--;) {\n            cache[uniqueID(elems[i])] = overflowing;\n        }return overflowing;\n    }\n\n    function overflowingAncestor(el) {\n        var elems = [];\n        var rootScrollHeight = root.scrollHeight;\n        do {\n            var cached = cache[uniqueID(el)];\n            if (cached) {\n                return setCache(elems, cached);\n            }\n            elems.push(el);\n            if (rootScrollHeight === el.scrollHeight) {\n                if (!isFrame || root.clientHeight + 10 < rootScrollHeight) {\n                    return setCache(elems, document.body); // scrolling root in WebKit\n                }\n            } else if (el.clientHeight + 10 < el.scrollHeight) {\n                overflow = getComputedStyle(el, \"\").getPropertyValue(\"overflow-y\");\n                if (overflow === \"scroll\" || overflow === \"auto\") {\n                    return setCache(elems, el);\n                }\n            }\n        } while (el = el.parentNode);\n    }\n\n    /***********************************************\n     * HELPERS\n     ***********************************************/\n\n    function addEvent(type, fn, bubble) {\n        window.addEventListener(type, fn, bubble || false);\n    }\n\n    function removeEvent(type, fn, bubble) {\n        window.removeEventListener(type, fn, bubble || false);\n    }\n\n    function isNodeName(el, tag) {\n        return (el.nodeName || \"\").toLowerCase() === tag.toLowerCase();\n    }\n\n    function directionCheck(x, y) {\n        x = x > 0 ? 1 : -1;\n        y = y > 0 ? 1 : -1;\n        if (direction.x !== x || direction.y !== y) {\n            direction.x = x;\n            direction.y = y;\n            que = [];\n            lastScroll = 0;\n        }\n    }\n\n    var deltaBufferTimer;\n\n    function isTouchpad(deltaY) {\n        if (!deltaY) return;\n        deltaY = Math.abs(deltaY);\n        deltaBuffer.push(deltaY);\n        deltaBuffer.shift();\n        clearTimeout(deltaBufferTimer);\n\n        var allEquals = deltaBuffer[0] == deltaBuffer[1] && deltaBuffer[1] == deltaBuffer[2];\n        var allDivisable = isDivisible(deltaBuffer[0], 120) && isDivisible(deltaBuffer[1], 120) && isDivisible(deltaBuffer[2], 120);\n        return !(allEquals || allDivisable);\n    }\n\n    function isDivisible(n, divisor) {\n        return Math.floor(n / divisor) == n / divisor;\n    }\n\n    var requestFrame = function () {\n        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || function (callback, element, delay) {\n            window.setTimeout(callback, delay || 1000 / 60);\n        };\n    }();\n\n    /***********************************************\n     * PULSE\n     ***********************************************/\n\n    /**\n     * Viscous fluid with a pulse for part and decay for the rest.\n     * - Applies a fixed force over an interval (a damped acceleration), and\n     * - Lets the exponential bleed away the velocity over a longer interval\n     * - Michael Herf, http://stereopsis.com/stopping/\n     */\n    function pulse_(x) {\n        var val, start, expx;\n        // test\n        x = x * options.pulseScale;\n        if (x < 1) {\n            // acceleartion\n            val = x - (1 - Math.exp(-x));\n        } else {\n            // tail\n            // the previous animation ended here:\n            start = Math.exp(-1);\n            // simple viscous drag\n            x -= 1;\n            expx = 1 - Math.exp(-x);\n            val = start + expx * (1 - start);\n        }\n        return val * options.pulseNormalize;\n    }\n\n    function pulse(x) {\n        if (x >= 1) return 1;\n        if (x <= 0) return 0;\n\n        if (options.pulseNormalize == 1) {\n            options.pulseNormalize /= pulse_(1);\n        }\n        return pulse_(x);\n    }\n\n    var isChrome = /chrome/i.test(window.navigator.userAgent);\n    var isMouseWheelSupported = 'onmousewheel' in document;\n\n    if (isMouseWheelSupported && isChrome) {\n        addEvent(\"mousedown\", mousedown);\n        addEvent(\"mousewheel\", wheel);\n        addEvent(\"load\", init);\n    };\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL3d3dy9qcy9TbW9vdGhTY3JvbGwuanM/MWI5NiJdLCJuYW1lcyI6WyJkZWZhdWx0T3B0aW9ucyIsImZyYW1lUmF0ZSIsImFuaW1hdGlvblRpbWUiLCJzdGVwU2l6ZSIsInB1bHNlQWxnb3JpdGhtIiwicHVsc2VTY2FsZSIsInB1bHNlTm9ybWFsaXplIiwiYWNjZWxlcmF0aW9uRGVsdGEiLCJhY2NlbGVyYXRpb25NYXgiLCJrZXlib2FyZFN1cHBvcnQiLCJhcnJvd1Njcm9sbCIsInRvdWNocGFkU3VwcG9ydCIsImZpeGVkQmFja2dyb3VuZCIsImV4Y2x1ZGVkIiwib3B0aW9ucyIsImlzRXhjbHVkZWQiLCJpc0ZyYW1lIiwiZGlyZWN0aW9uIiwieCIsInkiLCJpbml0RG9uZSIsInJvb3QiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImFjdGl2ZUVsZW1lbnQiLCJvYnNlcnZlciIsImRlbHRhQnVmZmVyIiwia2V5IiwibGVmdCIsInVwIiwicmlnaHQiLCJkb3duIiwic3BhY2ViYXIiLCJwYWdldXAiLCJwYWdlZG93biIsImVuZCIsImhvbWUiLCJpbml0VGVzdCIsImRpc2FibGVLZXlib2FyZCIsInJlbW92ZUV2ZW50Iiwia2V5ZG93biIsImFkZEV2ZW50IiwiaW5pdCIsImJvZHkiLCJodG1sIiwid2luZG93SGVpZ2h0Iiwid2luZG93IiwiaW5uZXJIZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJjb21wYXRNb2RlIiwiaW5kZXhPZiIsInRvcCIsInNlbGYiLCJvZmZzZXRIZWlnaHQiLCJzdHlsZSIsImhlaWdodCIsInNldFRpbWVvdXQiLCJyZWZyZXNoIiwidW5kZXJsYXkiLCJjcmVhdGVFbGVtZW50IiwiY2xlYXIiLCJhcHBlbmRDaGlsZCIsImJhY2tncm91bmRBdHRhY2htZW50IiwicXVlIiwicGVuZGluZyIsImxhc3RTY3JvbGwiLCJEYXRlIiwic2Nyb2xsQXJyYXkiLCJlbGVtIiwiZGVsYXkiLCJkaXJlY3Rpb25DaGVjayIsIm5vdyIsImVsYXBzZWQiLCJmYWN0b3IiLCJNYXRoIiwibWluIiwicHVzaCIsImxhc3RYIiwibGFzdFkiLCJzdGFydCIsInNjcm9sbFdpbmRvdyIsInN0ZXAiLCJ0aW1lIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJpIiwibGVuZ3RoIiwiaXRlbSIsImZpbmlzaGVkIiwicG9zaXRpb24iLCJwdWxzZSIsInNwbGljZSIsInNjcm9sbEJ5Iiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsInJlcXVlc3RGcmFtZSIsIndoZWVsIiwiZXZlbnQiLCJ0YXJnZXQiLCJvdmVyZmxvd2luZyIsIm92ZXJmbG93aW5nQW5jZXN0b3IiLCJkZWZhdWx0UHJldmVudGVkIiwiaXNOb2RlTmFtZSIsInRlc3QiLCJzcmMiLCJkZWx0YVgiLCJ3aGVlbERlbHRhWCIsImRlbHRhWSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YSIsImlzVG91Y2hwYWQiLCJhYnMiLCJwcmV2ZW50RGVmYXVsdCIsIm1vZGlmaWVyIiwiY3RybEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsImtleUNvZGUiLCJub2RlTmFtZSIsImlzQ29udGVudEVkaXRhYmxlIiwic2hpZnQiLCJjbGllbnRIZWlnaHQiLCJkYW10IiwibW91c2Vkb3duIiwiY2FjaGUiLCJzZXRJbnRlcnZhbCIsInVuaXF1ZUlEIiwiZWwiLCJzZXRDYWNoZSIsImVsZW1zIiwicm9vdFNjcm9sbEhlaWdodCIsImNhY2hlZCIsIm92ZXJmbG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJwYXJlbnROb2RlIiwidHlwZSIsImZuIiwiYnViYmxlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0YWciLCJ0b0xvd2VyQ2FzZSIsImRlbHRhQnVmZmVyVGltZXIiLCJjbGVhclRpbWVvdXQiLCJhbGxFcXVhbHMiLCJhbGxEaXZpc2FibGUiLCJpc0RpdmlzaWJsZSIsIm4iLCJkaXZpc29yIiwiZmxvb3IiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYWxsYmFjayIsImVsZW1lbnQiLCJwdWxzZV8iLCJ2YWwiLCJleHB4IiwiZXhwIiwiaXNDaHJvbWUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc01vdXNlV2hlZWxTdXBwb3J0ZWQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUMsWUFBVTs7QUFFWDtBQUNBLFFBQUlBLGlCQUFpQjs7QUFFakI7QUFDQUMsbUJBQW1CLEdBSEYsRUFHTztBQUN4QkMsdUJBQW1CLEdBSkYsRUFJTztBQUN4QkMsa0JBQW1CLEdBTEYsRUFLTzs7QUFFeEI7QUFDQTtBQUNBQyx3QkFBbUIsSUFURjtBQVVqQkMsb0JBQW1CLENBVkY7QUFXakJDLHdCQUFtQixDQVhGOztBQWFqQjtBQUNBQywyQkFBb0IsRUFkSCxFQWNRO0FBQ3pCQyx5QkFBb0IsQ0FmSCxFQWVROztBQUV6QjtBQUNBQyx5QkFBb0IsSUFsQkgsRUFrQlU7QUFDM0JDLHFCQUFvQixFQW5CSCxFQW1CVzs7QUFFNUI7QUFDQUMseUJBQW9CLElBdEJIO0FBdUJqQkMseUJBQW9CLElBdkJIO0FBd0JqQkMsa0JBQW9CO0FBeEJILEtBQXJCOztBQTJCQSxRQUFJQyxVQUFVZCxjQUFkOztBQUdBO0FBQ0EsUUFBSWUsYUFBYSxLQUFqQjtBQUNBLFFBQUlDLFVBQVUsS0FBZDtBQUNBLFFBQUlDLFlBQVksRUFBRUMsR0FBRyxDQUFMLEVBQVFDLEdBQUcsQ0FBWCxFQUFoQjtBQUNBLFFBQUlDLFdBQVksS0FBaEI7QUFDQSxRQUFJQyxPQUFPQyxTQUFTQyxlQUFwQjtBQUNBLFFBQUlDLGFBQUo7QUFDQSxRQUFJQyxRQUFKO0FBQ0EsUUFBSUMsY0FBYyxDQUFFLEdBQUYsRUFBTyxHQUFQLEVBQVksR0FBWixDQUFsQjs7QUFFQSxRQUFJQyxNQUFNLEVBQUVDLE1BQU0sRUFBUixFQUFZQyxJQUFJLEVBQWhCLEVBQW9CQyxPQUFP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LGtCQUFNOUUsUUFBUytFLFFBQVEsSUFBSS9FLEtBQVosQ0FBZjtBQUNIO0FBQ0QsZUFBTzhFLE1BQU0vSSxRQUFRUixjQUFyQjtBQUNIOztBQUVELGFBQVNvRixLQUFULENBQWV4RSxDQUFmLEVBQWtCO0FBQ2QsWUFBSUEsS0FBSyxDQUFULEVBQVksT0FBTyxDQUFQO0FBQ1osWUFBSUEsS0FBSyxDQUFULEVBQVksT0FBTyxDQUFQOztBQUVaLFlBQUlKLFFBQVFSLGNBQVIsSUFBMEIsQ0FBOUIsRUFBaUM7QUFDN0JRLG9CQUFRUixjQUFSLElBQTBCc0osT0FBTyxDQUFQLENBQTFCO0FBQ0g7QUFDRCxlQUFPQSxPQUFPMUksQ0FBUCxDQUFQO0FBQ0g7O0FBRUQsUUFBSThJLFdBQVcsVUFBVXpELElBQVYsQ0FBZXpELE9BQU9tSCxTQUFQLENBQWlCQyxTQUFoQyxDQUFmO0FBQ0EsUUFBSUMsd0JBQXdCLGtCQUFrQjdJLFFBQTlDOztBQUVBLFFBQUk2SSx5QkFBeUJILFFBQTdCLEVBQXVDO0FBQ3RDdkgsaUJBQVMsV0FBVCxFQUFzQm1GLFNBQXRCO0FBQ0FuRixpQkFBUyxZQUFULEVBQXVCdUQsS0FBdkI7QUFDQXZELGlCQUFTLE1BQVQsRUFBaUJDLElBQWpCO0FBQ0E7QUFFQSxDQW5nQkQiLCJmaWxlIjoiOTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTbW9vdGhTY3JvbGwgZm9yIHdlYnNpdGVzIHYxLjIuMVxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgbGljZW5zZS5cblxuLy8gUGVvcGxlIGludm9sdmVkXG4vLyAgLSBCYWxhenMgR2FsYW1ib3NpIChtYWludGFpbmVyKSAgXG4vLyAgLSBNaWNoYWVsIEhlcmYgICAgIChQdWxzZSBBbGdvcml0aG0pXG5cbihmdW5jdGlvbigpe1xuICBcbi8vIFNjcm9sbCBWYXJpYWJsZXMgKHR3ZWFrYWJsZSlcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcblxuICAgIC8vIFNjcm9sbGluZyBDb3JlXG4gICAgZnJhbWVSYXRlICAgICAgICA6IDE1MCwgLy8gW0h6XVxuICAgIGFuaW1hdGlvblRpbWUgICAgOiA0MDAsIC8vIFtweF1cbiAgICBzdGVwU2l6ZSAgICAgICAgIDogMTIwLCAvLyBbcHhdXG5cbiAgICAvLyBQdWxzZSAobGVzcyB0d2Vha2FibGUpXG4gICAgLy8gcmF0aW8gb2YgXCJ0YWlsXCIgdG8gXCJhY2NlbGVyYXRpb25cIlxuICAgIHB1bHNlQWxnb3JpdGhtICAgOiB0cnVlLFxuICAgIHB1bHNlU2NhbGUgICAgICAgOiA4LFxuICAgIHB1bHNlTm9ybWFsaXplICAgOiAxLFxuXG4gICAgLy8gQWNjZWxlcmF0aW9uXG4gICAgYWNjZWxlcmF0aW9uRGVsdGEgOiAyMCwgIC8vIDIwXG4gICAgYWNjZWxlcmF0aW9uTWF4ICAgOiAxLCAgIC8vIDFcblxuICAgIC8vIEtleWJvYXJkIFNldHRpbmdzXG4gICAga2V5Ym9hcmRTdXBwb3J0ICAgOiB0cnVlLCAgLy8gb3B0aW9uXG4gICAgYXJyb3dTY3JvbGwgICAgICAgOiA1MCwgICAgIC8vIFtweF1cblxuICAgIC8vIE90aGVyXG4gICAgdG91Y2hwYWRTdXBwb3J0ICAgOiB0cnVlLFxuICAgIGZpeGVkQmFja2dyb3VuZCAgIDogdHJ1ZSwgXG4gICAgZXhjbHVkZWQgICAgICAgICAgOiBcIlwiICAgIFxufTtcblxudmFyIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcblxuXG4vLyBPdGhlciBWYXJpYWJsZXNcbnZhciBpc0V4Y2x1ZGVkID0gZmFsc2U7XG52YXIgaXNGcmFtZSA9IGZhbHNlO1xudmFyIGRpcmVjdGlvbiA9IHsgeDogMCwgeTogMCB9O1xudmFyIGluaXREb25lICA9IGZhbHNlO1xudmFyIHJvb3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG52YXIgYWN0aXZlRWxlbWVudDtcbnZhciBvYnNlcnZlcjtcbnZhciBkZWx0YUJ1ZmZlciA9IFsgMTIwLCAxMjAsIDEyMCBdO1xuXG52YXIga2V5ID0geyBsZWZ0OiAzNywgdXA6IDM4LCByaWdodDogMzksIGRvd246IDQwLCBzcGFjZWJhcjogMzIsIFxuICAgICAgICAgICAgcGFnZXVwOiAzMywgcGFnZWRvd246IDM0LCBlbmQ6IDM1LCBob21lOiAzNiB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogU0VUVElOR1NcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIElOSVRJQUxJWkVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gKiBUZXN0cyBpZiBzbW9vdGggc2Nyb2xsaW5nIGlzIGFsbG93ZWQuIFNodXRzIGRvd24gZXZlcnl0aGluZyBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIGluaXRUZXN0KCkge1xuXG4gICAgdmFyIGRpc2FibGVLZXlib2FyZCA9IGZhbHNlOyBcbiAgICBcbiAgICAvLyBkaXNhYmxlIGtleWJvYXJkIHN1cHBvcnQgaWYgYW55dGhpbmcgYWJvdmUgcmVxdWVzdGVkIGl0XG4gICAgaWYgKGRpc2FibGVLZXlib2FyZCkge1xuICAgICAgICByZW1vdmVFdmVudChcImtleWRvd25cIiwga2V5ZG93bik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMua2V5Ym9hcmRTdXBwb3J0ICYmICFkaXNhYmxlS2V5Ym9hcmQpIHtcbiAgICAgICAgYWRkRXZlbnQoXCJrZXlkb3duXCIsIGtleWRvd24pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTZXRzIHVwIHNjcm9sbHMgYXJyYXksIGRldGVybWluZXMgaWYgZnJhbWVzIGFyZSBpbnZvbHZlZC5cbiAqL1xuZnVuY3Rpb24gaW5pdCgpIHtcbiAgXG4gICAgaWYgKCFkb2N1bWVudC5ib2R5KSByZXR1cm47XG5cbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgdmFyIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdmFyIHdpbmRvd0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDsgXG4gICAgdmFyIHNjcm9sbEhlaWdodCA9IGJvZHkuc2Nyb2xsSGVpZ2h0O1xuICAgIFxuICAgIC8vIGNoZWNrIGNvbXBhdCBtb2RlIGZvciByb290IGVsZW1lbnRcbiAgICByb290ID0gKGRvY3VtZW50LmNvbXBhdE1vZGUuaW5kZXhPZignQ1NTJykgPj0gMCkgPyBodG1sIDogYm9keTtcbiAgICBhY3RpdmVFbGVtZW50ID0gYm9keTtcbiAgICBcbiAgICBpbml0VGVzdCgpO1xuICAgIGluaXREb25lID0gdHJ1ZTtcblxuICAgIC8vIENoZWNrcyBpZiB0aGlzIHNjcmlwdCBpcyBydW5uaW5nIGluIGEgZnJhbWVcbiAgICBpZiAodG9wICE9IHNlbGYpIHtcbiAgICAgICAgaXNGcmFtZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmaXhlcyBhIGJ1ZyB3aGVyZSB0aGUgYXJlYXMgbGVmdCBhbmQgcmlnaHQgdG8gXG4gICAgICogdGhlIGNvbnRlbnQgZG9lcyBub3QgdHJpZ2dlciB0aGUgb25tb3VzZXdoZWVsIGV2ZW50XG4gICAgICogb24gc29tZSBwYWdlcy4gZS5nLjogaHRtbCwgYm9keSB7IGhlaWdodDogMTAwJSB9XG4gICAgICovXG4gICAgZWxzZSBpZiAoc2Nyb2xsSGVpZ2h0ID4gd2luZG93SGVpZ2h0ICYmXG4gICAgICAgICAgICAoYm9keS5vZmZzZXRIZWlnaHQgPD0gd2luZG93SGVpZ2h0IHx8IFxuICAgICAgICAgICAgIGh0bWwub2Zmc2V0SGVpZ2h0IDw9IHdpbmRvd0hlaWdodCkpIHtcblxuICAgICAgICBodG1sLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgc2V0VGltZW91dChyZWZyZXNoLCAxMCk7XG5cbiAgICAgICAgLy8gY2xlYXJmaXhcbiAgICAgICAgaWYgKHJvb3Qub2Zmc2V0SGVpZ2h0IDw9IHdpbmRvd0hlaWdodCkge1xuICAgICAgICAgICAgdmFyIHVuZGVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTsgXHRcbiAgICAgICAgICAgIHVuZGVybGF5LnN0eWxlLmNsZWFyID0gXCJib3RoXCI7XG4gICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKHVuZGVybGF5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRpc2FibGUgZml4ZWQgYmFja2dyb3VuZFxuICAgIGlmICghb3B0aW9ucy5maXhlZEJhY2tncm91bmQgJiYgIWlzRXhjbHVkZWQpIHtcbiAgICAgICAgYm9keS5zdHlsZS5iYWNrZ3JvdW5kQXR0YWNobWVudCA9IFwic2Nyb2xsXCI7XG4gICAgICAgIGh0bWwuc3R5bGUuYmFja2dyb3VuZEF0dGFjaG1lbnQgPSBcInNjcm9sbFwiO1xuICAgIH1cbn1cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBTQ1JPTExJTkcgXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuIFxudmFyIHF1ZSA9IFtdO1xudmFyIHBlbmRpbmcgPSBmYWxzZTtcbnZhciBsYXN0U2Nyb2xsID0gK25ldyBEYXRlO1xuXG4vKipcbiAqIFB1c2hlcyBzY3JvbGwgYWN0aW9ucyB0byB0aGUgc2Nyb2xsaW5nIHF1ZXVlLlxuICovXG5mdW5jdGlvbiBzY3JvbGxBcnJheShlbGVtLCBsZWZ0LCB0b3AsIGRlbGF5KSB7XG4gICAgXG4gICAgZGVsYXkgfHwgKGRlbGF5ID0gMTAwMCk7XG4gICAgZGlyZWN0aW9uQ2hlY2sobGVmdCwgdG9wKTtcblxuICAgIGlmIChvcHRpb25zLmFjY2VsZXJhdGlvbk1heCAhPSAxKSB7XG4gICAgICAgIHZhciBub3cgPSArbmV3IERhdGU7XG4gICAgICAgIHZhciBlbGFwc2VkID0gbm93IC0gbGFzdFNjcm9sbDtcbiAgICAgICAgaWYgKGVsYXBzZWQgPCBvcHRpb25zLmFjY2VsZXJhdGlvbkRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgZmFjdG9yID0gKDEgKyAoMzAgLyBlbGFwc2VkKSkgLyAyO1xuICAgICAgICAgICAgaWYgKGZhY3RvciA+IDEpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3IgPSBNYXRoLm1pbihmYWN0b3IsIG9wdGlvbnMuYWNjZWxlcmF0aW9uTWF4KTtcbiAgICAgICAgICAgICAgICBsZWZ0ICo9IGZhY3RvcjtcbiAgICAgICAgICAgICAgICB0b3AgICo9IGZhY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0U2Nyb2xsID0gK25ldyBEYXRlO1xuICAgIH0gICAgICAgICAgXG4gICAgXG4gICAgLy8gcHVzaCBhIHNjcm9sbCBjb21tYW5kXG4gICAgcXVlLnB1c2goe1xuICAgICAgICB4OiBsZWZ0LCBcbiAgICAgICAgeTogdG9wLCBcbiAgICAgICAgbGFzdFg6IChsZWZ0IDwgMCkgPyAwLjk5IDogLTAuOTksXG4gICAgICAgIGxhc3RZOiAodG9wICA8IDApID8gMC45OSA6IC0wLjk5LCBcbiAgICAgICAgc3RhcnQ6ICtuZXcgRGF0ZVxuICAgIH0pO1xuICAgICAgICBcbiAgICAvLyBkb24ndCBhY3QgaWYgdGhlcmUncyBhIHBlbmRpbmcgcXVldWVcbiAgICBpZiAocGVuZGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfSAgXG5cbiAgICB2YXIgc2Nyb2xsV2luZG93ID0gKGVsZW0gPT09IGRvY3VtZW50LmJvZHkpO1xuICAgIFxuICAgIHZhciBzdGVwID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBub3cgPSArbmV3IERhdGU7XG4gICAgICAgIHZhciBzY3JvbGxYID0gMDtcbiAgICAgICAgdmFyIHNjcm9sbFkgPSAwOyBcbiAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBxdWVbaV07XG4gICAgICAgICAgICB2YXIgZWxhcHNlZCAgPSBub3cgLSBpdGVtLnN0YXJ0O1xuICAgICAgICAgICAgdmFyIGZpbmlzaGVkID0gKGVsYXBzZWQgPj0gb3B0aW9ucy5hbmltYXRpb25UaW1lKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gc2Nyb2xsIHBvc2l0aW9uOiBbMCwgMV1cbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IChmaW5pc2hlZCkgPyAxIDogZWxhcHNlZCAvIG9wdGlvbnMuYW5pbWF0aW9uVGltZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gZWFzaW5nIFtvcHRpb25hbF1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnB1bHNlQWxnb3JpdGhtKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwdWxzZShwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIG9ubHkgbmVlZCB0aGUgZGlmZmVyZW5jZVxuICAgICAgICAgICAgdmFyIHggPSAoaXRlbS54ICogcG9zaXRpb24gLSBpdGVtLmxhc3RYKSA+PiAwO1xuICAgICAgICAgICAgdmFyIHkgPSAoaXRlbS55ICogcG9zaXRpb24gLSBpdGVtLmxhc3RZKSA+PiAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBhZGQgdGhpcyB0byB0aGUgdG90YWwgc2Nyb2xsaW5nXG4gICAgICAgICAgICBzY3JvbGxYICs9IHg7XG4gICAgICAgICAgICBzY3JvbGxZICs9IHk7ICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBsYXN0IHZhbHVlc1xuICAgICAgICAgICAgaXRlbS5sYXN0WCArPSB4O1xuICAgICAgICAgICAgaXRlbS5sYXN0WSArPSB5O1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIGRlbGV0ZSBhbmQgc3RlcCBiYWNrIGlmIGl0J3Mgb3ZlclxuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgcXVlLnNwbGljZShpLCAxKTsgaS0tO1xuICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICAvLyBzY3JvbGwgbGVmdCBhbmQgdG9wXG4gICAgICAgIGlmIChzY3JvbGxXaW5kb3cpIHtcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxCeShzY3JvbGxYLCBzY3JvbGxZKTtcbiAgICAgICAgfSBcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsWCkgZWxlbS5zY3JvbGxMZWZ0ICs9IHNjcm9sbFg7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsWSkgZWxlbS5zY3JvbGxUb3AgICs9IHNjcm9sbFk7ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gY2xlYW4gdXAgaWYgdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG9cbiAgICAgICAgaWYgKCFsZWZ0ICYmICF0b3ApIHtcbiAgICAgICAgICAgIHF1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAocXVlLmxlbmd0aCkgeyBcbiAgICAgICAgICAgIHJlcXVlc3RGcmFtZShzdGVwLCBlbGVtLCAoZGVsYXkgLyBvcHRpb25zLmZyYW1lUmF0ZSArIDEpKTsgXG4gICAgICAgIH0gZWxzZSB7IFxuICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBzdGFydCBhIG5ldyBxdWV1ZSBvZiBhY3Rpb25zXG4gICAgcmVxdWVzdEZyYW1lKHN0ZXAsIGVsZW0sIDApO1xuICAgIHBlbmRpbmcgPSB0cnVlO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogRVZFTlRTXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICogTW91c2Ugd2hlZWwgaGFuZGxlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICovXG5mdW5jdGlvbiB3aGVlbChldmVudCkge1xuXG4gICAgaWYgKCFpbml0RG9uZSkge1xuICAgICAgICBpbml0KCk7XG4gICAgfVxuICAgIFxuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIG92ZXJmbG93aW5nID0gb3ZlcmZsb3dpbmdBbmNlc3Rvcih0YXJnZXQpO1xuICAgIFxuICAgIC8vIHVzZSBkZWZhdWx0IGlmIHRoZXJlJ3Mgbm8gb3ZlcmZsb3dpbmdcbiAgICAvLyBlbGVtZW50IG9yIGRlZmF1bHQgYWN0aW9uIGlzIHByZXZlbnRlZCAgICBcbiAgICBpZiAoIW92ZXJmbG93aW5nIHx8IGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHxcbiAgICAgICAgaXNOb2RlTmFtZShhY3RpdmVFbGVtZW50LCBcImVtYmVkXCIpIHx8XG4gICAgICAgKGlzTm9kZU5hbWUodGFyZ2V0LCBcImVtYmVkXCIpICYmIC9cXC5wZGYvaS50ZXN0KHRhcmdldC5zcmMpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVsdGFYID0gZXZlbnQud2hlZWxEZWx0YVggfHwgMDtcbiAgICB2YXIgZGVsdGFZID0gZXZlbnQud2hlZWxEZWx0YVkgfHwgMDtcbiAgICBcbiAgICAvLyB1c2Ugd2hlZWxEZWx0YSBpZiBkZWx0YVgvWSBpcyBub3QgYXZhaWxhYmxlXG4gICAgaWYgKCFkZWx0YVggJiYgIWRlbHRhWSkge1xuICAgICAgICBkZWx0YVkgPSBldmVudC53aGVlbERlbHRhIHx8IDA7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgaXQncyBhIHRvdWNocGFkIHNjcm9sbCB0aGF0IHNob3VsZCBiZSBpZ25vcmVkXG4gICAgaWYgKCFvcHRpb25zLnRvdWNocGFkU3VwcG9ydCAmJiBpc1RvdWNocGFkKGRlbHRhWSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gc2NhbGUgYnkgc3RlcCBzaXplXG4gICAgLy8gZGVsdGEgaXMgMTIwIG1vc3Qgb2YgdGhlIHRpbWVcbiAgICAvLyBzeW5hcHRpY3Mgc2VlbXMgdG8gc2VuZCAxIHNvbWV0aW1lc1xuICAgIGlmIChNYXRoLmFicyhkZWx0YVgpID4gMS4yKSB7XG4gICAgICAgIGRlbHRhWCAqPSBvcHRpb25zLnN0ZXBTaXplIC8gMTIwO1xuICAgIH1cbiAgICBpZiAoTWF0aC5hYnMoZGVsdGFZKSA+IDEuMikge1xuICAgICAgICBkZWx0YVkgKj0gb3B0aW9ucy5zdGVwU2l6ZSAvIDEyMDtcbiAgICB9XG4gICAgXG4gICAgc2Nyb2xsQXJyYXkob3ZlcmZsb3dpbmcsIC1kZWx0YVgsIC1kZWx0YVkpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbi8qKlxuICogS2V5ZG93biBldmVudCBoYW5kbGVyLlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGtleWRvd24oZXZlbnQpIHtcblxuICAgIHZhciB0YXJnZXQgICA9IGV2ZW50LnRhcmdldDtcbiAgICB2YXIgbW9kaWZpZXIgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5tZXRhS2V5IHx8IFxuICAgICAgICAgICAgICAgICAgKGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50LmtleUNvZGUgIT09IGtleS5zcGFjZWJhcik7XG4gICAgXG4gICAgLy8gZG8gbm90aGluZyBpZiB1c2VyIGlzIGVkaXRpbmcgdGV4dFxuICAgIC8vIG9yIHVzaW5nIGEgbW9kaWZpZXIga2V5IChleGNlcHQgc2hpZnQpXG4gICAgLy8gb3IgaW4gYSBkcm9wZG93blxuICAgIGlmICggL2lucHV0fHRleHRhcmVhfHNlbGVjdHxlbWJlZC9pLnRlc3QodGFyZ2V0Lm5vZGVOYW1lKSB8fFxuICAgICAgICAgdGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlIHx8IFxuICAgICAgICAgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCAgIHx8XG4gICAgICAgICBtb2RpZmllciApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBzcGFjZWJhciBzaG91bGQgdHJpZ2dlciBidXR0b24gcHJlc3NcbiAgICBpZiAoaXNOb2RlTmFtZSh0YXJnZXQsIFwiYnV0dG9uXCIpICYmXG4gICAgICAgIGV2ZW50LmtleUNvZGUgPT09IGtleS5zcGFjZWJhcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIHZhciBzaGlmdCwgeCA9IDAsIHkgPSAwO1xuICAgIHZhciBlbGVtID0gb3ZlcmZsb3dpbmdBbmNlc3RvcihhY3RpdmVFbGVtZW50KTtcbiAgICB2YXIgY2xpZW50SGVpZ2h0ID0gZWxlbS5jbGllbnRIZWlnaHQ7XG5cbiAgICBpZiAoZWxlbSA9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIGNsaWVudEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSBrZXkudXA6XG4gICAgICAgICAgICB5ID0gLW9wdGlvbnMuYXJyb3dTY3JvbGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBrZXkuZG93bjpcbiAgICAgICAgICAgIHkgPSBvcHRpb25zLmFycm93U2Nyb2xsO1xuICAgICAgICAgICAgYnJlYWs7ICAgICAgICAgXG4gICAgICAgIGNhc2Uga2V5LnNwYWNlYmFyOiAvLyAoKyBzaGlmdClcbiAgICAgICAgICAgIHNoaWZ0ID0gZXZlbnQuc2hpZnRLZXkgPyAxIDogLTE7XG4gICAgICAgICAgICB5ID0gLXNoaWZ0ICogY2xpZW50SGVpZ2h0ICogMC45O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Uga2V5LnBhZ2V1cDpcbiAgICAgICAgICAgIHkgPSAtY2xpZW50SGVpZ2h0ICogMC45O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Uga2V5LnBhZ2Vkb3duOlxuICAgICAgICAgICAgeSA9IGNsaWVudEhlaWdodCAqIDAuOTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGtleS5ob21lOlxuICAgICAgICAgICAgeSA9IC1lbGVtLnNjcm9sbFRvcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGtleS5lbmQ6XG4gICAgICAgICAgICB2YXIgZGFtdCA9IGVsZW0uc2Nyb2xsSGVpZ2h0IC0gZWxlbS5zY3JvbGxUb3AgLSBjbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICB5ID0gKGRhbXQgPiAwKSA/IGRhbXQrMTAgOiAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Uga2V5LmxlZnQ6XG4gICAgICAgICAgICB4ID0gLW9wdGlvbnMuYXJyb3dTY3JvbGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBrZXkucmlnaHQ6XG4gICAgICAgICAgICB4ID0gb3B0aW9ucy5hcnJvd1Njcm9sbDtcbiAgICAgICAgICAgIGJyZWFrOyAgICAgICAgICAgIFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIGEga2V5IHdlIGRvbid0IGNhcmUgYWJvdXRcbiAgICB9XG5cbiAgICBzY3JvbGxBcnJheShlbGVtLCB4LCB5KTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG4vKipcbiAqIE1vdXNlZG93biBldmVudCBvbmx5IGZvciB1cGRhdGluZyBhY3RpdmVFbGVtZW50XG4gKi9cbmZ1bmN0aW9uIG1vdXNlZG93bihldmVudCkge1xuICAgIGFjdGl2ZUVsZW1lbnQgPSBldmVudC50YXJnZXQ7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBPVkVSRkxPV1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuIFxudmFyIGNhY2hlID0ge307IC8vIGNsZWFyZWQgb3V0IGV2ZXJ5IG9uY2UgaW4gd2hpbGVcbnNldEludGVydmFsKGZ1bmN0aW9uICgpIHsgY2FjaGUgPSB7fTsgfSwgMTAgKiAxMDAwKTtcblxudmFyIHVuaXF1ZUlEID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gZWwudW5pcXVlSUQgfHwgKGVsLnVuaXF1ZUlEID0gaSsrKTtcbiAgICB9O1xufSkoKTtcblxuZnVuY3Rpb24gc2V0Q2FjaGUoZWxlbXMsIG92ZXJmbG93aW5nKSB7XG4gICAgZm9yICh2YXIgaSA9IGVsZW1zLmxlbmd0aDsgaS0tOylcbiAgICAgICAgY2FjaGVbdW5pcXVlSUQoZWxlbXNbaV0pXSA9IG92ZXJmbG93aW5nO1xuICAgIHJldHVybiBvdmVyZmxvd2luZztcbn1cblxuZnVuY3Rpb24gb3ZlcmZsb3dpbmdBbmNlc3RvcihlbCkge1xuICAgIHZhciBlbGVtcyA9IFtdO1xuICAgIHZhciByb290U2Nyb2xsSGVpZ2h0ID0gcm9vdC5zY3JvbGxIZWlnaHQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgY2FjaGVkID0gY2FjaGVbdW5pcXVlSUQoZWwpXTtcbiAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldENhY2hlKGVsZW1zLCBjYWNoZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1zLnB1c2goZWwpO1xuICAgICAgICBpZiAocm9vdFNjcm9sbEhlaWdodCA9PT0gZWwuc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoIWlzRnJhbWUgfHwgcm9vdC5jbGllbnRIZWlnaHQgKyAxMCA8IHJvb3RTY3JvbGxIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0Q2FjaGUoZWxlbXMsIGRvY3VtZW50LmJvZHkpOyAvLyBzY3JvbGxpbmcgcm9vdCBpbiBXZWJLaXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlbC5jbGllbnRIZWlnaHQgKyAxMCA8IGVsLnNjcm9sbEhlaWdodCkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBnZXRDb21wdXRlZFN0eWxlKGVsLCBcIlwiKS5nZXRQcm9wZXJ0eVZhbHVlKFwib3ZlcmZsb3cteVwiKTtcbiAgICAgICAgICAgIGlmIChvdmVyZmxvdyA9PT0gXCJzY3JvbGxcIiB8fCBvdmVyZmxvdyA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0Q2FjaGUoZWxlbXMsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGVsID0gZWwucGFyZW50Tm9kZSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBIRUxQRVJTXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmZ1bmN0aW9uIGFkZEV2ZW50KHR5cGUsIGZuLCBidWJibGUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgKGJ1YmJsZXx8ZmFsc2UpKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnQodHlwZSwgZm4sIGJ1YmJsZSkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCAoYnViYmxlfHxmYWxzZSkpOyAgXG59XG5cbmZ1bmN0aW9uIGlzTm9kZU5hbWUoZWwsIHRhZykge1xuICAgIHJldHVybiAoZWwubm9kZU5hbWV8fFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IHRhZy50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBkaXJlY3Rpb25DaGVjayh4LCB5KSB7XG4gICAgeCA9ICh4ID4gMCkgPyAxIDogLTE7XG4gICAgeSA9ICh5ID4gMCkgPyAxIDogLTE7XG4gICAgaWYgKGRpcmVjdGlvbi54ICE9PSB4IHx8IGRpcmVjdGlvbi55ICE9PSB5KSB7XG4gICAgICAgIGRpcmVjdGlvbi54ID0geDtcbiAgICAgICAgZGlyZWN0aW9uLnkgPSB5O1xuICAgICAgICBxdWUgPSBbXTtcbiAgICAgICAgbGFzdFNjcm9sbCA9IDA7XG4gICAgfVxufVxuXG52YXIgZGVsdGFCdWZmZXJUaW1lcjtcblxuZnVuY3Rpb24gaXNUb3VjaHBhZChkZWx0YVkpIHtcbiAgICBpZiAoIWRlbHRhWSkgcmV0dXJuO1xuICAgIGRlbHRhWSA9IE1hdGguYWJzKGRlbHRhWSlcbiAgICBkZWx0YUJ1ZmZlci5wdXNoKGRlbHRhWSk7XG4gICAgZGVsdGFCdWZmZXIuc2hpZnQoKTtcbiAgICBjbGVhclRpbWVvdXQoZGVsdGFCdWZmZXJUaW1lcik7XG5cbiAgICB2YXIgYWxsRXF1YWxzICAgID0gKGRlbHRhQnVmZmVyWzBdID09IGRlbHRhQnVmZmVyWzFdICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFCdWZmZXJbMV0gPT0gZGVsdGFCdWZmZXJbMl0pO1xuICAgIHZhciBhbGxEaXZpc2FibGUgPSAoaXNEaXZpc2libGUoZGVsdGFCdWZmZXJbMF0sIDEyMCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRGl2aXNpYmxlKGRlbHRhQnVmZmVyWzFdLCAxMjApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RpdmlzaWJsZShkZWx0YUJ1ZmZlclsyXSwgMTIwKSk7XG4gICAgcmV0dXJuICEoYWxsRXF1YWxzIHx8IGFsbERpdmlzYWJsZSk7XG59IFxuXG5mdW5jdGlvbiBpc0RpdmlzaWJsZShuLCBkaXZpc29yKSB7XG4gICAgcmV0dXJuIChNYXRoLmZsb29yKG4gLyBkaXZpc29yKSA9PSBuIC8gZGl2aXNvcik7XG59XG5cbnZhciByZXF1ZXN0RnJhbWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgIHx8IFxuICAgICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoY2FsbGJhY2ssIGVsZW1lbnQsIGRlbGF5KSB7XG4gICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgZGVsYXkgfHwgKDEwMDAvNjApKTtcbiAgICAgICAgICAgICAgfTtcbn0pKCk7XG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBQVUxTRVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuIFxuLyoqXG4gKiBWaXNjb3VzIGZsdWlkIHdpdGggYSBwdWxzZSBmb3IgcGFydCBhbmQgZGVjYXkgZm9yIHRoZSByZXN0LlxuICogLSBBcHBsaWVzIGEgZml4ZWQgZm9yY2Ugb3ZlciBhbiBpbnRlcnZhbCAoYSBkYW1wZWQgYWNjZWxlcmF0aW9uKSwgYW5kXG4gKiAtIExldHMgdGhlIGV4cG9uZW50aWFsIGJsZWVkIGF3YXkgdGhlIHZlbG9jaXR5IG92ZXIgYSBsb25nZXIgaW50ZXJ2YWxcbiAqIC0gTWljaGFlbCBIZXJmLCBodHRwOi8vc3RlcmVvcHNpcy5jb20vc3RvcHBpbmcvXG4gKi9cbmZ1bmN0aW9uIHB1bHNlXyh4KSB7XG4gICAgdmFyIHZhbCwgc3RhcnQsIGV4cHg7XG4gICAgLy8gdGVzdFxuICAgIHggPSB4ICogb3B0aW9ucy5wdWxzZVNjYWxlO1xuICAgIGlmICh4IDwgMSkgeyAvLyBhY2NlbGVhcnRpb25cbiAgICAgICAgdmFsID0geCAtICgxIC0gTWF0aC5leHAoLXgpKTtcbiAgICB9IGVsc2UgeyAgICAgLy8gdGFpbFxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgYW5pbWF0aW9uIGVuZGVkIGhlcmU6XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5leHAoLTEpO1xuICAgICAgICAvLyBzaW1wbGUgdmlzY291cyBkcmFnXG4gICAgICAgIHggLT0gMTtcbiAgICAgICAgZXhweCA9IDEgLSBNYXRoLmV4cCgteCk7XG4gICAgICAgIHZhbCA9IHN0YXJ0ICsgKGV4cHggKiAoMSAtIHN0YXJ0KSk7XG4gICAgfVxuICAgIHJldHVybiB2YWwgKiBvcHRpb25zLnB1bHNlTm9ybWFsaXplO1xufVxuXG5mdW5jdGlvbiBwdWxzZSh4KSB7XG4gICAgaWYgKHggPj0gMSkgcmV0dXJuIDE7XG4gICAgaWYgKHggPD0gMCkgcmV0dXJuIDA7XG5cbiAgICBpZiAob3B0aW9ucy5wdWxzZU5vcm1hbGl6ZSA9PSAxKSB7XG4gICAgICAgIG9wdGlvbnMucHVsc2VOb3JtYWxpemUgLz0gcHVsc2VfKDEpO1xuICAgIH1cbiAgICByZXR1cm4gcHVsc2VfKHgpO1xufVxuXG52YXIgaXNDaHJvbWUgPSAvY2hyb21lL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgaXNNb3VzZVdoZWVsU3VwcG9ydGVkID0gJ29ubW91c2V3aGVlbCcgaW4gZG9jdW1lbnQ7IFxuXG5pZiAoaXNNb3VzZVdoZWVsU3VwcG9ydGVkICYmIGlzQ2hyb21lKSB7XG5cdGFkZEV2ZW50KFwibW91c2Vkb3duXCIsIG1vdXNlZG93bik7XG5cdGFkZEV2ZW50KFwibW91c2V3aGVlbFwiLCB3aGVlbCk7XG5cdGFkZEV2ZW50KFwibG9hZFwiLCBpbml0KTtcbn07XG5cbn0pKCk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy93d3cvanMvU21vb3RoU2Nyb2xsLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///90\n");

/***/ })

/******/ });